<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Spring bean 的声明和注入</title>
    <url>/2020/07/15/blog10/</url>
    <content><![CDATA[<p>Spring bean 就是可重用组件，是 Spring 的基础。</p>
<p>通过 @Component 注解将一个类声明为 bean，交给 Spring 管理，并在需要的时候注入获取实例。这就是 Spring 重要的 IOC 功能。</p>
<p>今天研究的问题出现在<strong><u>注入</u></strong>这一步：在对一个工具类注入 RedisCache（封装了 RedisTemplate 的工具类），由于工具类使用了静态方法，导致无法获取到注入的 RedisCache。</p>
<h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><p>首先来认识一下 static 可以作用的对象：</p>
<h4 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h4><p>又称为类变量，也就是说这个变量属于类的，类所有的实例都共享静态变量，可以直接通过类名来访问它。静态变量在内存中只存在一份。当类被 Java 虚拟机加载的时候，会对 static 变量进行初始化。静态变量存放在 Java 内存区域的方法区。而实例变量每创建一个实例就会产生一个，它与该实例同生共死。</p>
<h4 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h4><p>在类加载的时候就存在了，它不依赖于任何实例。所以静态方法必须有实现，也就是说它不能是抽象方法。只能访问所属类的静态字段和静态方法（初始化顺序），方法中不能有 this 和 super 关键字（静态不需要对象）。调用静态方法可以无需创建对象（如果使用对象.静态方法会在编译后翻译为类.静态方法）。如果方法执行的操作不依赖于其类的各个变量和方法，设置为静态使程序的占用空间更小。</p>
<h4 id="静态语句块"><a href="#静态语句块" class="headerlink" title="静态语句块"></a>静态语句块</h4><p>静态代码块定义在类中方法外，静态代码块在非静态代码块之前执行。该类不管创建多少对象，在类初始化时运行一次。</p>
<h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h4><p>非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围类，但是静态内部类却没有。非静态内部类依赖于外部类的实例，也就是说需要先创建外部类实例，才能用这个实例去创建非静态内部类。而静态内部类不需要。静态内部类不能访问外部类的非静态的变量和方法。</p>
<h4 id="静态导包"><a href="#静态导包" class="headerlink" title="静态导包"></a>静态导包</h4><p>JDK1.5</p>
<p>我们这里使用的是<u><strong>静态方法</strong></u>，属于类，而不属于某个实例，调用静态方法时不会创建对象。</p>
<p>静态方法还提到了初始化顺序：</p>
<h4 id="初始化顺序"><a href="#初始化顺序" class="headerlink" title="初始化顺序"></a>初始化顺序</h4><p>静态变量和静态语句块 -&gt; 实例变量和普通语句块 -&gt; 构造函数。静态变量和静态语句块的初始化顺序取决于它们在代码中的顺序。</p>
<p><strong>存在继承时的初始化顺序</strong></p>
<ol>
<li><p>父类（静态变量、静态语句块）</p>
</li>
<li><p>子类（静态变量、静态语句块）</p>
</li>
<li><p>父类（实例变量、普通语句块）</p>
</li>
<li><p>父类（构造函数）</p>
</li>
<li><p>子类（实例变量、普通语句块）</p>
</li>
<li><p>子类（构造函数）</p>
</li>
</ol>
<h3 id="bean-的声明"><a href="#bean-的声明" class="headerlink" title="bean 的声明"></a>bean 的声明</h3><p>共有四种方式将将一个<u><strong>类</strong></u>声明为 bean 的注解：</p>
<h4 id="Component"><a href="#Component" class="headerlink" title="@Component"></a>@Component</h4><p>通用的注解，可标注任意类为 Spring 组件。如果一个 bean 不知道属于哪个层，可以使用 @Component 注解标注。创建对象，把当前对象存入 Spring 容器中，相当于 XML 的 &lt; bean&gt;。</p>
<h4 id="Repository"><a href="#Repository" class="headerlink" title="@Repository"></a>@Repository</h4><p>对应持久层，主要用于数据库相关操作。</p>
<h4 id="Service"><a href="#Service" class="headerlink" title="@Service"></a>@Service</h4><p>对应服务层，主要涉及一些复杂的逻辑。</p>
<h4 id="Controller"><a href="#Controller" class="headerlink" title="@Controller"></a>@Controller</h4><p>对应控制层，主要用户接受用户请求并返回数据给前端页面。</p>
<p>@Bean 注解作用于<u><strong>方法</strong></u>，对比一下 @Component ：</p>
<h4 id="Component-和-Bean-的区别"><a href="#Component-和-Bean-的区别" class="headerlink" title="@Component 和 @Bean 的区别"></a>@Component 和 @Bean 的区别</h4><p>@Component 注解作用于类，而 @Bean 注解作用于方法。</p>
<p>@Component 通常是通过类路径扫描来自动侦测以及自动装配到 Spring 容器中，@Bean 注解通常是在标有该注解的方法中定义产生这个 bean。</p>
<p>@Bean 注解比 Component 注解的自定义性更强，而且很多地方我们只能通过 @Bean 注解来注册 bean。比如当我们引用第三方库中的类需要装配到 Spring 容器时，则只能通过 @Bean 来实现。</p>
<h3 id="bean-的注入"><a href="#bean-的注入" class="headerlink" title="bean 的注入"></a>bean 的注入</h3><p>@Autowired 可以实现自动装配，对象无需自己查找或创建与其关联的其他对象，由容器负责把需要相互协作的对象引用赋予各个对象。</p>
<h4 id="容器中查询对应类型的-bean"><a href="#容器中查询对应类型的-bean" class="headerlink" title="容器中查询对应类型的 bean"></a>容器中查询对应类型的 bean</h4><ol>
<li><p>如果查询结果刚好为一个，就将该 bean 装配给 @Autowired 指定的数据。</p>
</li>
<li><p>如果查询的结果不止一个，那么 @Autowired 会根据名称来查找。</p>
</li>
<li><p>如果上述查找的结果为空，那么会抛出异常。解决方法：使用 required=false。</p>
</li>
</ol>
<p>@Resource、@Inject、@Qualifier 和 @Value 也可以实现同样的装配效果。</p>
<h4 id="Autowired-和-Resource-之间的区别"><a href="#Autowired-和-Resource-之间的区别" class="headerlink" title="@Autowired 和 @Resource 之间的区别"></a>@Autowired 和 @Resource 之间的区别</h4><ul>
<li><p>@Autowired 默认是按照类型装配注入的。</p>
</li>
<li><p>@Resource 默认是按照名称来装配注入的，只有当找不到与名称匹配的 bean 才会按照类型来装配注入。</p>
</li>
</ul>
<h4 id="Qualifier"><a href="#Qualifier" class="headerlink" title="@Qualifier"></a>@Qualifier</h4><p>在按照类注入的基础上再根据名称注入。给类注入时不能单独使用，需要配合 @Autowired。给方法和变量注入时可以单独使用。</p>
<h4 id="Value"><a href="#Value" class="headerlink" title="@Value"></a>@Value</h4><p>基本类型和 String 无法用 @Autowired、@Resource 和 @Qualifier 实现，需要使用 @Value。可以配合 Spring 的 EL 表达式 SpEL。</p>
<h3 id="问题的分析和解决方案"><a href="#问题的分析和解决方案" class="headerlink" title="问题的分析和解决方案"></a>问题的分析和解决方案</h3><p>了解了 static、bean 的声明和注入后，来看一下出问题的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> RedisCache redisCache;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sendSms</span><span class="params">(String[] phoneNumbers)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    redisCache.setCacheObject(key,code);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原来为了 TxsmsUtils.sendSms() 方便而将这个方法设置为 static，在方法内使用 redisCache 时需要 redisCache 也是静态的。</p>
<p>然而像上面分析的，静态变量属于类，而不属于某个实例，不会由 Spring 注入并创建对象。因此 sendSms() 这个方法中是获取不到 redisCache 对象的，因此出错。</p>
<p>解决：将 sendSms() 和 redisCache 设置为非静态，即去除 static。</p>
<p>另外，对于工具类，如果需要使用其他组件，需要将工具类也声明为 Spring bean，交给 Spring 来控制，这样才能获取到组件的实例。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>静态方法中无法进行获取到 Spring bean 的实例，看似直接明了的结论，若不是像我一样在实际开发过程中遇到过 bug，并从头到尾排查一边，真的得很难有完整的理解。</p>
<p>读万卷书，行万里路。要在懂得理论知识的前提下，积极实践，总结错误。我的这条路才刚刚开始。</p>
]]></content>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>欢迎来到我的网站</title>
    <url>/2020/02/14/blog1/</url>
    <content><![CDATA[<p>&emsp;&emsp;Hello, developers!</p>
<p>&emsp;&emsp;这是本网站的第一篇博客，希望从这以后我能督促自己，以学习和分享为目的，产出高质量的技术博客。如果能带给大家帮助，我将感到万分荣幸！</p>
<p>&emsp;&emsp;本网站用于记录我日常编程开发的心得体会，主要但不限于 Java 后端开发方向，还会有工具箱用来记录自己平时遇到高频关键的快捷键和命令，以及挂几个小项目。</p>
<p>&emsp;&emsp;欢迎小伙伴们的到来，衷心希望能与各位成为朋友。</p>
<p>&emsp;&emsp;Enjoy coding &amp; peace！</p>
]]></content>
      <tags>
        <tag>welcome</tag>
      </tags>
  </entry>
  <entry>
    <title>Selenium IDE 的简单使用</title>
    <url>/2020/02/20/blog3/</url>
    <content><![CDATA[<p>研一上的软件测试课接到的任务，要求上去给大伙儿演示使用 Selenium 做自动测试，实现录制和重放 Selenium 脚本，并在命令行运行脚本。由于没有任何文档，只能硬着头皮面向 Google 学习，力求能做出个玩样儿交差。</p>
<p>首先了解下 Selenium：</p>
<img src="/images/blog3/屏幕快照 2019-12-25 22.59.02.png" />

<p>这是官网给的定义，大致是说 Selenium 主要是用来构建网站上的自动测试。</p>
<p>我这次的任务主要使用 Selenium IDE 这个插件来做的，特点是录制和重放特别得傻瓜式。</p>
<img src="/images/blog3/屏幕快照 2019-12-25 23.02.10.png" width="50%" />

<p>输入一个 URL，点击按钮</p>
<p><img src="/images/blog3/a.png" alt="avatar"></p>
<p>Selenium IDE 就会把你在之后对网站各种元素的操作记录下来，录制形成多条命令：</p>
<img src="/images/blog3/屏幕快照 2019-12-25 23.05.57.png" width="35%" />

<p>然后点击按钮</p>
<img src="/images/blog3/屏幕快照 2019-12-25 23.06.11.png" />

<p>就可以重放了。由于是软件测试课，需要加 assert 进行判断结果对错。</p>
<p>这里注意 assert 和 verify 两个判断：assert 遇到判断为错，会结束整个测试；而 verify 会继续后面的测试命令。</p>
<p>到这里会发现 Selenium IDE 是真的简单，但是我想说我被坑了，坑在用命令行重放录制的 .py 脚本。这里其实大部分是我是个 Unix 命令行小白，对文件系统不是很熟悉，想要找一个文件在哪还要 Google 基本的 which 命令。但是还有一部分是官方文档有一处坑。</p>
<p>Selenium IDE 的 Help 可以直接进到官方文档：</p>
<img src="/images/blog3/屏幕快照 2019-12-25 23.13.37.png" width="50%" />

<p>对，就是这个 Command-line Runner。前置装 node，selenium-side-runner 和 chromedriver，我安装文档给的 npm 装一直报错（一部分是因为图书馆网太差），一部分是版本问题。最后装完了运行 selenium-side-runner /path/to/your-project.side 时，报了 no test 的错误。为什么呢？还好有 Code Export，把前面录制的脚本到处为 .py 文件，发现：</p>
<img src="/images/blog3/屏幕快照 2019-12-25 23.18.22.png" width="75%" />

<p>这个导出的文件没有 main 函数！因此又回到官方文档，仔细思索端倪：</p>
<img src="/images/blog3/屏幕快照 2019-12-25 23.19.38.png" width="50%" />

<p>原来得用 pytest 运行这个脚本，按照文档一路搞下来的我上当了，真有你的 selenium-side-runner！然鹅待我装了前置后，运行  pytest /path/to/your-project.py 后，又报错了，这次是 no element 的错误。Google 一番，发现是浏览器打开 URL 太慢，而脚本先执行了 driver.find_element() 这一步。解决办法是用 WebDriverWait(self.driver, 20).until(EC.element_to_be_clickable()).click()，等 URL 打开了再执行点击。这一次终于完事了！</p>
<p>经过两天的苦搞，上台演示的时候还有点小兴奋！最后老师说的一句话肯定了我：Jieb 同学演示的教会了我一些知识。不过确实，在学校教书写论文的教授的思维和如此极速发展的互联网相比，难免滞后，我也不过是官网文档和各类博客的搬运工，都是受到互联万物的网络的启发。</p>
<p>尽管做的内容很小，但是是自己不断尝错探索出来的，是一种船新的感觉，因此打算写个博客记录一下。相信这迈出的第一步，能是今后千万里长路的开端！</p>
]]></content>
      <tags>
        <tag>other</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 后端开发技术选型</title>
    <url>/2020/03/01/blog4/</url>
    <content><![CDATA[<p>根据我的理解，简单谈下如何选择 Java 后端开发所用到的技术。</p>
<h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><p>Java 语言是这篇博客的核心，无论是写业务，还是底层框架的构成，都用到 Java 编写。</p>
<p>Java 相关的要点有：Java 基础，Java 容器，Java I/O，JVM 和 Java 并发。包括下面列举的要点，都在我整理的思维导图中：<a href="https://naotu.baidu.com/file/801377570e88e491545c2eed6cdfbd42?token=ba146c8e8cbca0be" target="_blank" rel="noopener">思维导图</a>，密码为 Pm6j。</p>
<img src="/images/blog4/java.svg" width="30%" />

<h2 id="Java-语言的发展"><a href="#Java-语言的发展" class="headerlink" title="Java 语言的发展"></a>Java 语言的发展</h2><p>Java 最初由任职于 Sun Microsystems 的 James Gosling 等人于 1990 年代初开发，最初被命名为 Oak，目标为家用电器等小型系统，应用在电视机、电话、闹钟、烤面包机等家用电器的控制和通信。由于这些智能化家电的市场需求没有预期的高，Sun 放弃了该项计划。</p>
<p>随着 1990 年代互联网的发展，Sun 看见 Oak 在互联网上应用的前景，于是改造了 Oak，于 1995 年 5 月 23 日以 Java 的名称正式发布。Java 伴随着互联网的迅猛发展而发展，逐渐成为重要的网络编程语言。次年 JDK1.0 诞生。</p>
<p>2004 年 9 月 30 日，J2SE1.5 发布，成为 Java 语言发展史上的里程碑。为了表示该版本的重要性，J2SE1.5 更名为 Java SE 5.0。</p>
<p>2006 年 Sun 在 JavaOne 公布 Java 开放源代码项目，并推出 OpenJDK 项目。Java 虚拟机、Java 编译器和 Java 类库以 GNU 通用公共许可证公开。</p>
<p>2009 年 4 月 20 日，Oracle 收购 Sun，此时是 Java 6。</p>
<p>2014 年 3 月 18 日，Oracle 发布 Java SE 8，成为现在 Java 开发的主流版本。我总结了 Java SE 8 主要的新特性：</p>
<p>1.lambda 表达式和函数式接口</p>
<p>2.Optional</p>
<p>3.Stream</p>
<p>4.新的日期和时间 API</p>
<p>5.接口的默认方法</p>
<p>6.多重注解</p>
<p>从 2017 年 9 月开始，每半年发布一个 Java SE 版本。到写这篇博客的时候，Java 来到了 Java SE 13。</p>
<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><p>操作系统和下面将谈到的计算机网络可以说是计算机专业最基础的两门课程，学好两者对于开发大有裨益。</p>
<p>os 相关的要点有：进程与线程，进程调度，进程同步，进程通信，死锁，内存管理。</p>
<p>os 主流为 Linux、Microsoft 和 macOS。对于软件开发而言，Linux 已经成为了主流，一个应用的运维离不开 Linux。由于 Linux 的开源、免费和稳定，现在 90% 以上的企业采用 Linux，服务端的市场已经被 Linux 占领。</p>
<img src="/images/blog4/linux.png" width="30%" />

<p>Linux 相关的要点有：文件，目录，磁盘，vi 和 vim，bash，正则表达式，进程管理，网络。</p>
<p>另外，除了 Linux，我在使用 Microsoft 和 macOS 两个操作系统后，明显感觉 macOS 会更加舒服，体现在高效的触控板，精美的 UI 和类 Unix 的便捷等等。</p>
<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><p>network 相关的要点有：分层协议，物理层，数据链路层，网络层，传输层，应用层。</p>
<p>网络部分还有两个重点：UNP 和 HTTP。</p>
<p>UNP 的要点包括：套接字，I/O 模型，I/O 复用。</p>
<p>HTTP 在网站开发部分可谓重中之重，现在流行的 RESTful 软件架构风格就是以 HTTP 为基础的。HTTP 的要点包括：HTTP 方法，HTTP 状态码，HTTP 请求响应报文结构，Cookie &amp; Session，缓存，HTTPS，HTTP/2，同源和跨域策略。</p>
<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><p>数据库部分包括计算机专业涉及到的数据库原理部分，以及 MySQL 和 Redis。数据库在后端方向尤为重要。</p>
<p>数据库原理的要点：SQL 语句，表相关语句，关系数据库，事务，视图等。另外在实际开发中，还需要注意 SQL 注入攻击，数据库连接池和 JDBC。</p>
<h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><p>MySQL 开源免费，而 Oracle 价格较高。作为学习的工具，建议使用 MySQL。另外，推荐使用 Navicat 作为管理 MySQL 的工具。</p>
<img src="/images/blog4/mysql.png" width="30%" />

<p>MySQL 的要点：索引，查询性能优化，存储引擎，切分，复制，并发一致性问题，隔离级别，封锁，MVCC。</p>
<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><p>Redis 主要用在缓存上，支持简单的键值对存储。缓存的主要目的是高性能和高可用，在项目的性能优化方面很有用，但吃透 Redis 还是很耗时间的。</p>
<img src="/images/blog4/redis.png" width="30%" />

<p>Redis 的要点：数据类型，使用场景，与 Memcached 的比较，数据淘汰策略，持久化，事务&amp;事件，复制，哨兵，分片，集群，缓存问题，一致性哈希，单线程模型。</p>
<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><p>Spring 系列是 Java 后端开发结合最紧密的框架，加快了应用的开发，学好用好 Spring 对于项目的开发至关重要。现在流行的 SSM 是首选，即 SpringMVC，Spring，MyBatis。关于三者的整合我写过 <a href="">SSM 整合</a>。</p>
<img src="/images/blog4/spring.png" width="30%" />

<p>Spring 的要点：AOP，IOC，MVC，bean，注解，事务，Spring Boot 相关。</p>
<p>相比国内较火的 MyBatis，Hibernate 更加重量级，功能更多且较难上手，不过也是持久层的一个选择。</p>
<p><img src="/images/blog4/mybatis.jpeg" width="30%" /> <img src="/images/blog4/hibernate.png" width="30%" /></p>
<h1 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h1><p>分布式在现在网络并发量高，流量大的形势下显得尤为重要。分布式部分涉及到：分布式锁，分布式事务，CAP 和 BASE，分布式一致性算法，分布式计算。</p>
<p>Spring Cloud 和 Dubbo 构成微服务，以服务的形式把一个项目分成多个模块。当然 Spring Cloud 现在有两个分支，一个为 Spring Cloud Alibaba 和 Dubbo，还包括 Sentinel、Nacos、RocketMQ、Seata 等，是国人开发的微服务架构。另一个则是 Spring Cloud Netflix，包括 Ribbon、Feign、Eureka（停止更新）、Hystrix 等。现在开发微服务也可以直接使用 Kubernetes。</p>
<img src="/images/blog4/dubbo.png" width="10%" />

<p>Dubbo 的要点：RPC，工作原理，通信协议和序列化协议，负载均衡策略和集群容错策略、动态代理策略，spi 思想。</p>
<p>Elasticsearch 是基于 Lucene 的搜索引擎。</p>
<img src="/images/blog4/elasticsearch.png" width="30%" />

<p>Hystrix 资源隔离、降级和熔断。</p>
<img src="/images/blog4/hystrix.png" width="30%" />

<p>Nginx 反向代理和负载均衡服务器。</p>
<img src="/images/blog4/nginx.png" width="30%" />

<p>ZooKeeper 配置和管理分布式组件。</p>
<img src="/images/blog4/zookeeper.jpeg" width="30%" />

<p>RocketMQ 和 Kafka 分布式架构的消息队列。</p>
<p><img src="/images/blog4/rocketmq.jpeg" width="20%" /> <img src="/images/blog4/kafka.png" width="20%" /></p>
<h1 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h1><p>我在开发过程中主要用到 Git 和 Maven。另外 Docker 是可以解决环境配置问题的一种虚拟化技术。</p>
<img src="/images/blog4/docker.png" width="30%" />

<p>Git 用来解决分布式版本控制问题，Maven 有依赖管理和一键构建两大功能。</p>
<img src="/images/blog4/git.png" width="30%" />

<img src="/images/blog4/maven.png" width="30%" />

]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>SSM 整合</title>
    <url>/2020/02/19/blog2/</url>
    <content><![CDATA[<p>我写篇博客记录上个阶段学习的 SSM 整合，加深一下自己对 Spring 这块知识的理解。</p>
<h1 id="什么是-SSM"><a href="#什么是-SSM" class="headerlink" title="什么是 SSM"></a>什么是 SSM</h1><p>SSM 是 Spring、SpringMVC、MyBatis 三者的缩写。根据三者的职能对应 SSM 的三层架构：<br>表现层 SpringMVC：接受用户参数，显示页面。<br>业务层 Spring：处理业务逻辑。<br>持久层 MyBatis：操作数据库。</p>
<p><img src="/images/blog2/SSM.png" alt="avatar"></p>
<p>从上图我们可以看到三层模型之间的依赖关系，并且 Spring 是三者的核心。</p>
<h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><h2 id="使用-MySQL-创建-account-表"><a href="#使用-MySQL-创建-account-表" class="headerlink" title="使用 MySQL 创建 account 表"></a>使用 MySQL 创建 account 表</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table account(</span><br><span class="line">    id int primary key auto_increment,</span><br><span class="line">    name varchar(20),</span><br><span class="line">    money double</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><img src="/images/blog2/structure.png" width="50%">

<h2 id="使用-Maven-导入项目所需依赖-JAR-包"><a href="#使用-Maven-导入项目所需依赖-JAR-包" class="headerlink" title="使用 Maven 导入项目所需依赖 JAR 包"></a>使用 Maven 导入项目所需依赖 JAR 包</h2><p>aspectj、spring-aop、spring-context、spring-web、spring-webmvc、spring-tx、spring-jdbc、mysql-connector-java、javax.servlet、mybatis、mybatis-spring、c3p0 和其他日志等 JAR 包。</p>
<h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><p>编写 Account 类，编写属性 id、name 和 money，这一步和上面创建的 account 表属性相对应。并设置 get/set 方法和 toString 方法。</p>
<p>编写 AccountDao 接口，实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 查询所有账户</span><br><span class="line">@Select(&quot;select * from account&quot;)</span><br><span class="line">public List&lt;Account&gt; findAll();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 插入帐户信息</span><br><span class="line">@Insert(&quot;insert into account (name,money) values (#&#123;name&#125;,#&#123;money&#125;)&quot;)</span><br><span class="line">public void saveAccount(Account account);</span><br></pre></td></tr></table></figure>

<p>接着 AccountServiceImpl 和 AccountController 就可以逐层调用这里的 find 和 save 方法。<br>编写 JSP 文件用来显示页面。</p>
<h1 id="整合部分"><a href="#整合部分" class="headerlink" title="整合部分"></a>整合部分</h1><h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><p>applicationContext.xml 是 Spring 的配置文件，也是 SSM 整合中的核心配置文件。负责依赖注入、声明式事务、AOP 和整合 MyBatis。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--开启注解的扫描，并且 Controller 不需要 Spring 去处理--&gt;</span><br><span class="line">&lt;context:component-scan base-package&#x3D;&quot;com.jieb&quot; &gt;</span><br><span class="line">    &lt;!--配置哪些注解不扫描--&gt;</span><br><span class="line">    &lt;context:exclude-filter type&#x3D;&quot;annotation&quot; expression&#x3D;&quot;org.springframework.stereotype.Controller&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;context:component-scan&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--声明式事务--&gt;</span><br><span class="line">&lt;!--事务管理器--&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;transactionManager&quot; class&#x3D;&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;dataSource&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--事务通知--&gt;</span><br><span class="line">&lt;tx:advice id&#x3D;&quot;txAdvice&quot; transaction-manager&#x3D;&quot;transactionManager&quot;&gt;</span><br><span class="line">    &lt;tx:attributes&gt;</span><br><span class="line">        &lt;tx:method name&#x3D;&quot;find*&quot; read-only&#x3D;&quot;true&quot;&#x2F;&gt;</span><br><span class="line">        &lt;tx:method name&#x3D;&quot;*&quot; isolation&#x3D;&quot;DEFAULT&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;tx:attributes&gt;</span><br><span class="line">&lt;&#x2F;tx:advice&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--AOP--&gt;</span><br><span class="line">&lt;aop:config&gt;</span><br><span class="line">    &lt;aop:advisor advice-ref&#x3D;&quot;txAdvice&quot; pointcut&#x3D;&quot;execution(* com.jieb.service.impl.*ServiceImpl.*(..))&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;aop:config&gt;</span><br></pre></td></tr></table></figure>

<h2 id="Spring-整合-MyBatis"><a href="#Spring-整合-MyBatis" class="headerlink" title="Spring 整合 MyBatis"></a>Spring 整合 MyBatis</h2><p>MyBatis 的主配置文件 configuration.xml 被整合到了 applicationContext.xml 之中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--Spring 整合 MyBatis--&gt;</span><br><span class="line">&lt;!--配置连接池--&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;dataSource&quot; class&#x3D;&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;driverClass&quot; value&#x3D;&quot;com.mysql.jdbc.Driver&quot;&#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;jdbcUrl&quot; value&#x3D;&quot;jdbc:mysql:&#x2F;&#x2F;&#x2F;ssm&quot;&#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;user&quot; value&#x3D;&quot;root&quot;&#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;root&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--配置 SqlSessionFactory 工厂--&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;sqlSessionFactory&quot; class&#x3D;&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;dataSource&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--配置 AccountDao 接口所在包--&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;mapperScanner&quot; class&#x3D;&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;basePackage&quot; value&#x3D;&quot;com.jieb.dao&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>

<h2 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h2><p>springmvc.xml 和 web.xml 是 SpringMVC 的配置文件。<br>springmvc.xml 负责开启注解扫描，配置视图解析器以及过滤静态资源。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--开启注解扫描，只扫描 Controller 注解--&gt;</span><br><span class="line">&lt;context:component-scan base-package&#x3D;&quot;com.jieb&quot;&gt;</span><br><span class="line">    &lt;context:include-filter type&#x3D;&quot;annotation&quot; expression&#x3D;&quot;org.springframework.stereotype.Controller&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;context:component-scan&gt;</span><br></pre></td></tr></table></figure>

<p>可以看到，Spring 整合 SpringMVC，需要把 Controller 类的工作独立出来，交给 SpringMVC 来做。Controller 属于表现层。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--配置的视图解析器对象--&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;internalResourceViewResolver&quot; class&#x3D;&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;prefix&quot; value&#x3D;&quot;&#x2F;WEB-INF&#x2F;pages&#x2F;&quot;&#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;suffix&quot; value&#x3D;&quot;.jsp&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--过滤静态资源--&gt;</span><br><span class="line">&lt;mvc:resources location&#x3D;&quot;&#x2F;css&#x2F;&quot; mapping&#x3D;&quot;&#x2F;css&#x2F;**&quot; &#x2F;&gt;</span><br><span class="line">&lt;mvc:resources location&#x3D;&quot;&#x2F;images&#x2F;&quot; mapping&#x3D;&quot;&#x2F;images&#x2F;**&quot; &#x2F;&gt;</span><br><span class="line">&lt;mvc:resources location&#x3D;&quot;&#x2F;js&#x2F;&quot; mapping&#x3D;&quot;&#x2F;js&#x2F;**&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure>

<p>web.xml 负责配置 Spring 的监听器，配置前端控制器和解决中文乱码的过滤器。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--配置 Spring 监听器，默认只加载 WEB-INF 目录下的 applicationContext.xml 配置文件--&gt;</span><br><span class="line">&lt;listener&gt;</span><br><span class="line">    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;&#x2F;listener-class&gt;</span><br><span class="line">&lt;&#x2F;listener&gt;</span><br><span class="line">&lt;!--设置配置文件的路径--&gt;</span><br><span class="line">&lt;context-param&gt;</span><br><span class="line">    &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;</span><br><span class="line">    &lt;param-value&gt;classpath:applicationContext.xml&lt;&#x2F;param-value&gt;</span><br><span class="line">&lt;&#x2F;context-param&gt;</span><br><span class="line">&lt;context-param&gt;</span><br><span class="line">    &lt;param-name&#x2F;&gt;</span><br><span class="line">    &lt;param-value&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;context-param&gt;</span><br></pre></td></tr></table></figure>

<p>监听器是 Spring 整合 SpringMVC 的核心，启动 Tomcat 服务器的时候加载 Spring 的配置文件 applicationContext.xml，用到监听器 ContextLoaderListener 监听 ServletContext 对象，让监听器取加载 Spring 的配置文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--配置前端控制器--&gt;</span><br><span class="line">&lt;servlet&gt;</span><br><span class="line">    &lt;servlet-name&gt;dispatcherServlet&lt;&#x2F;servlet-name&gt;</span><br><span class="line">    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;&#x2F;servlet-class&gt;</span><br><span class="line">    &lt;!--加载springmvc.xml配置文件--&gt;</span><br><span class="line">    &lt;init-param&gt;</span><br><span class="line">        &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;</span><br><span class="line">        &lt;param-value&gt;classpath:springmvc.xml&lt;&#x2F;param-value&gt;</span><br><span class="line">    &lt;&#x2F;init-param&gt;</span><br><span class="line">    &lt;!--启动服务器，创建该servlet--&gt;</span><br><span class="line">    &lt;load-on-startup&gt;1&lt;&#x2F;load-on-startup&gt;</span><br><span class="line">&lt;&#x2F;servlet&gt;</span><br><span class="line">&lt;servlet-mapping&gt;</span><br><span class="line">    &lt;servlet-name&gt;dispatcherServlet&lt;&#x2F;servlet-name&gt;</span><br><span class="line">    &lt;url-pattern&gt;&#x2F;&lt;&#x2F;url-pattern&gt;</span><br><span class="line">&lt;&#x2F;servlet-mapping&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--解决中文乱码的过滤器--&gt;</span><br><span class="line">&lt;filter&gt;</span><br><span class="line">    &lt;filter-name&gt;characterEncodingFilter&lt;&#x2F;filter-name&gt;</span><br><span class="line">    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;&#x2F;filter-class&gt;</span><br><span class="line">    &lt;init-param&gt;</span><br><span class="line">        &lt;param-name&gt;encoding&lt;&#x2F;param-name&gt;</span><br><span class="line">        &lt;param-value&gt;UTF-8&lt;&#x2F;param-value&gt;</span><br><span class="line">    &lt;&#x2F;init-param&gt;</span><br><span class="line">&lt;&#x2F;filter&gt;</span><br><span class="line">&lt;filter-mapping&gt;</span><br><span class="line">    &lt;filter-name&gt;characterEncodingFilter&lt;&#x2F;filter-name&gt;</span><br><span class="line">    &lt;url-pattern&gt;&#x2F;*&lt;&#x2F;url-pattern&gt;</span><br><span class="line">&lt;&#x2F;filter-mapping&gt;</span><br></pre></td></tr></table></figure>

<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>其实写博客就是一个向他人讲述的过程，根据费曼学习法，在向他人讲述一个知识点的过程中，查漏补缺，最终得到知识的升华。写博客确实是一件非常有价值的事。</p>
]]></content>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>PuTTY 的安装与使用</title>
    <url>/2020/05/06/blog6/</url>
    <content><![CDATA[<p>我在看博客时遇到博主使用 PuTTY 作为 SSH 连接的客户端，打算借助网上其他博客，学习一下 PuTTY 的简单使用。</p>
<h2 id="PuTTY-是什么？"><a href="#PuTTY-是什么？" class="headerlink" title="PuTTY 是什么？"></a>PuTTY 是什么？</h2><p>PuTTY 是一款集成虚拟终端、系统控制台和网络文件传输为一体的自由及开放源代码的程序。包含 PSCP、PSFTP 等多个特定功能的客户端，</p>
<h2 id="mac-下-PuTTY-的安装"><a href="#mac-下-PuTTY-的安装" class="headerlink" title="mac 下 PuTTY 的安装"></a>mac 下 PuTTY 的安装</h2><h3 id="安装-MacPorts"><a href="#安装-MacPorts" class="headerlink" title="安装 MacPorts"></a>安装 MacPorts</h3><p>MacPorts 是一个包管理工具，类似 Homebrew。之所以使用 MacPorts，是因为 MacPorts 和 PuTTY 一样，都是远古时期的老家伙。我用 MacPorts 安装 PuTTY 没有出现问题，首先在<br><a href="https://distfiles.macports.org/MacPorts/" target="_blank" rel="noopener">https://distfiles.macports.org/MacPorts/</a> 上找到自己 macOS 版本所对应的 MacPorts 版本，安装完成后在终端更新 port：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo port -v selfupdate</span><br></pre></td></tr></table></figure>

<h3 id="安装-GTK"><a href="#安装-GTK" class="headerlink" title="安装 GTK+"></a>安装 GTK+</h3><p>PuTTY 使用的 GTK+ 图形界面，现在可以使用 port 安装 GTK+：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo port install gtk2</span><br></pre></td></tr></table></figure>

<h3 id="安装-XQuartz"><a href="#安装-XQuartz" class="headerlink" title="安装 XQuartz"></a>安装 XQuartz</h3><p>XQuartz 提供绘图层支持，在 <a href="https://www.xquartz.org/" target="_blank" rel="noopener">https://www.xquartz.org/</a> 下载并安装。</p>
<h3 id="安装-PuTTY"><a href="#安装-PuTTY" class="headerlink" title="安装 PuTTY"></a>安装 PuTTY</h3><p>完成上述三个前置后，通过 port 安装 PuTTY：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo port install putty</span><br></pre></td></tr></table></figure>

<h2 id="PuTTY-的使用"><a href="#PuTTY-的使用" class="headerlink" title="PuTTY 的使用"></a>PuTTY 的使用</h2><h3 id="通过-XQuartz-打开-PuTTY"><a href="#通过-XQuartz-打开-PuTTY" class="headerlink" title="通过 XQuartz 打开 PuTTY"></a>通过 XQuartz 打开 PuTTY</h3><p>完成了 PuTTY 的安装后，首先打开 XQuartz 程序，在菜单栏的应用程序中，找到<u>终端</u>，如图：</p>
<img src="/images/blog6/截屏2020-05-06上午11.58.17.png" />

<p>打开终端后，输入 <code>putty</code> 即可打开 PuTTY 的配置界面：</p>
<img src="/images/blog6/截屏2020-05-06下午12.00.20.png" width="50%" />

<p>输入访问的 IP 地址，<code>open</code> 即可打开 PuTTY 的终端：</p>
<img src="/images/blog6/截屏2020-05-06下午12.02.15.png" />

<p>然鹅，使用 root 登录后出现了 Access denied 的错误，在<br><a href="https://superuser.com/questions/539139/putty-password-access-denied" target="_blank" rel="noopener">https://superuser.com/questions/539139/putty-password-access-denied</a> 这个解答中有很明确的解释，在 <u>/etc/ssh/sshd_config </u>中加上：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PermitRootLogin yes</span><br></pre></td></tr></table></figure>

<p>完美解决 Access denied 的问题，连接到了我访问的阿里云服务器。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>PuTTY 的安装巨费时间，使用起来也是不太方便，毕竟远古产物，现在不怎么会去使用它。mac 上自带的终端进行 ssh 连接或者阿里云的远程连接都远比 PuTTY 实际。</p>
]]></content>
      <tags>
        <tag>other</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL &amp; Redis 技术分享-下</title>
    <url>/2020/06/01/blog9/</url>
    <content><![CDATA[<p>上一篇博客主要谈到 MySQL 的基础知识和高级特性，现在让我们看一下 Redis 部分。</p>
<h2 id="Redis-基础"><a href="#Redis-基础" class="headerlink" title="Redis 基础"></a>Redis 基础</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Redis 是速度非常快的非关系型内存键值数据库。<br>Redis 和 MySQL 不同之处在于，Redis 用的是 NoSQL。<br>主要用作缓存，缓存目的：</p>
<ul>
<li>高性能：操作缓存就是直接操作内存，所以速度相当快。</li>
<li>高并发：直接操作缓存能够承受的请求是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。并且缓存是走内存的，内存天然就支撑高并发。</li>
</ul>
<h3 id="为什么速度快？"><a href="#为什么速度快？" class="headerlink" title="为什么速度快？"></a>为什么速度快？</h3><ul>
<li>核心是基于非阻塞的 I/O 多路复用机制，用很少的线程也能快速处理大量任务。</li>
<li>完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于 HashMap，查找和增删的时间复杂度都是 O(1)。</li>
<li>采用单线程，数据全都在内存里，单线程去操作就是效率最高的。同时避免了不必要的上下文切换和竞争问题而消耗 CPU，不用去考虑多线程同步和各种锁的问题，如加锁释放锁和死锁导致的性能消耗。另外，单线程天然支持原子操作。</li>
</ul>
<p>其他原因：</p>
<ul>
<li>数据结构简单，对数据操作也简单。</li>
<li>底层模型，Redis 构建了自己的 VM 机制。</li>
<li>C 语言实现。</li>
<li>客户端与服务端通信使用 Redis 序列化协议 RESP 进行通信。</li>
</ul>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ul>
<li>STRING，可以实现常规 key-value 缓存应用和计数。</li>
<li>LIST，可以实现分页查询和消息队列。</li>
<li>SET，可以实现共同好友和去重。</li>
<li>HASH，可以实现存储对象。</li>
<li>ZSET，可以实现排行榜。ZSET增加了一个权重参数 score，使得集合中的元素能够按 score 进行有序排列。</li>
</ul>
<h4 id="Jedis-实现数据类型的基本操作"><a href="#Jedis-实现数据类型的基本操作" class="headerlink" title="Jedis 实现数据类型的基本操作"></a>Jedis 实现数据类型的基本操作</h4><p>同样演示代码在 <a href="https://github.com/Jiebupup/demo" target="_blank" rel="noopener">https://github.com/Jiebupup/demo</a> 中有，介绍了 Jedis 对应上述五个数据类型的操作。 </p>
<h3 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h3><p>Redis 是内存型数据库，为了保证数据在断电后不会丢失，需要将内存中的数据持久化到硬盘上。</p>
<h4 id="RDB-快照"><a href="#RDB-快照" class="headerlink" title="RDB 快照"></a>RDB 快照</h4><p>创建快照来获得存储在内存里面的数据在某个时间点上的副本，再存放到硬盘上。</p>
<p>实际操作过程是 fork 一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储。</p>
<p>可以将快照复制到其它服务器从而创建具有相同数据的服务器副本（就是 Redis 的主从结构），还可以将快照留在原服务器以便重启服务器的时候使用。<br>如果系统发生故障，将会丢失最后一次创建快照之后的数据。<br>如果数据量很大，保存快照的时间会很长。</p>
<h4 id="AOF-文件"><a href="#AOF-文件" class="headerlink" title="AOF 文件"></a>AOF 文件</h4><p>将写命令添加到 AOF 文件（Append Only File）的末尾。</p>
<p>设置同步选项：使用 AOF 持久化需要设置同步选项，从而确保写命令同步到磁盘文件上的时机。这是因为对文件进行写入并不会马上将内容同步到磁盘上，而是先存储到缓冲区，然后由操作系统决定什么时候同步到磁盘。</p>
<ul>
<li>always：会严重减低服务器的性能。</li>
<li>everysec：比较合适，可以保证系统崩溃时只会丢失一秒左右的数据，并且 Redis 每秒执行一次同步对服务器性能几乎没有任何影响。</li>
<li>no：并不能给服务器性能带来多大的提升，而且也会增加系统崩溃时数据丢失的数量。</li>
</ul>
<p>AOF 重写：随着服务器写请求的增多，AOF 文件会越来越大。Redis 提供了一种将 AOF 重写的特性，能够去除 AOF 文件中的冗余写命令。</p>
<h2 id="Redis-高级特性"><a href="#Redis-高级特性" class="headerlink" title="Redis 高级特性"></a>Redis 高级特性</h2><h3 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h3><p>Redis 的复制与 MySQL 主从复制类似。<br>Redis 复制水平扩容支撑读高并发，并且从 Redis 2.8 开始支持断点续传，即主从复制过程中，网络连接断掉了，那么可以接着上次复制的地方，继续复制下去。</p>
<h3 id="哨兵"><a href="#哨兵" class="headerlink" title="哨兵"></a>哨兵</h3><p>可以监听集群中的服务器，并在主服务器进入下线状态时，自动从从服务器中选举出新的主服务器。<br>用于实现 Redis 集群的高可用，本身也是作为一个哨兵集群去运行，互相协同工作。</p>
<h3 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h3><p>集群中有多个 master 节点，每个 master 又有多个 slave 节点。和哨兵共同实现了集群的高可用。</p>
<p>Gossip 协议与集中式协议不同：所有节点都持有一份元数据，不同的节点如果出现了元数据的变更，就不断将元数据发送给其它的节点，让其它节点也进行元数据的变更。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>总结一下这一次的技术分享。首先，分享的内容比较便基础，在整理出大量的知识点的同时，我也准备了几个 demo，争取让参与分享的同学巩固一下数据库这块的知识。</p>
<p>然后就是自己的表达能力需要提升提升，这也是我写这两篇博客的目的，希望自己能在总结和写作中，锻炼自己的表达能力。</p>
<p>最后还是谈谈我对 MySQL &amp; Redis 学习的看法，我总结的只是部分知识点，MySQL &amp; Redis 的理论知识点偏多，需要记忆的内容也很多。并且在个人项目或者不需要高并发的项目中，很多内容都用不上，用的最多的还是 CRUD。因此我认为熟练地 CRUD 还是很重要的，毕竟是各种项目的基础。如果要想提高自己的能力，对于高阶的知识点还是该记记该背背，更加重要的是写 demo，用代码实战过。  </p>
]]></content>
      <tags>
        <tag>backend</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis 与 Hibernate 对比</title>
    <url>/2020/03/30/blog5/</url>
    <content><![CDATA[<p>在我之前写过的 <a href="http://www.jiebcoder.top/2020/02/19/blog2/">SSM 整合</a> 中，作为三层架构中的持久层，MyBatis 负责操作数据库。</p>
<p>同样本文和 MyBatis 进行对比的 Hibernate，也是当下十分火热的持久层选项。</p>
<h1 id="JPA"><a href="#JPA" class="headerlink" title="JPA"></a>JPA</h1><p>要讲 Hibernate，首先需要提到 JPA。JPA 即 Java 持久化 API，是一种规范，而 Hibernate 和 TopLink 都是其实现方式。</p>
<p>Spring Data JPA 是对 JPA 的封装。</p>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>标准化：任何符合 JPA 标准的框架都遵循同样的架构，提供相同的访问 API，经过少量的修改就能够在环境下运行。</p>
<p>容器级特性的支持：JPA 框架中支持大数据集、事务、并发等容器级事务。</p>
<p>查询能力：JPA 的查询语言是面向对象而非面向数据库的，它的查询语句 JPQL 查询的是实体类和实体类的属性。</p>
<p>高级特性：JPA 中能够支持面向对象的高级特性，如类之间的继承、多态和类之间的复杂关系。</p>
<h1 id="Hibernate"><a href="#Hibernate" class="headerlink" title="Hibernate"></a>Hibernate</h1><img src="/images/blog4/hibernate.png" width="30%" />

<p>Hibernate 是一个开放源代码的对象关系映射框架，它对 JDBC 进行了非常轻量级的对象封装，它将 POJO 与数据库表建立映射关系，是一个全自动的 ORM 框架，Hibernate 可以自动生成 SQL 语句，自动执行，使得 Java 程序员可以随心所欲的使用对象编程思维来操纵数据库。 </p>
<p>Hibernate 可以应用在任何使用 JDBC 的场合，既可以在 Java 的客户端程序使用，也可以在 Servlet/JSP 的 Web 应用中使用，最具革命意义的是，Hibernate 可以在应用 EJB 的 JaveEE 架构中取代 CMP，完成数据持久化的重任。</p>
<h1 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h1><img src="/images/blog4/mybatis.jpeg" width="30%" />

<p>MyBatis 是一个 Java 持久化框架，它通过 XML 描述符或注解把对象与存储过程或 SQL 语句关联起来。</p>
<p>MyBatis 是在 Apache 许可证 2.0 下分发的自由软件，是 iBATIS 3.0 的分支版本。</p>
<p>与其他的对象关系映射框架不同，MyBatis 并没有将 Java 对象与数据库表关联起来，而是将 Java 方法与 SQL 语句关联。</p>
<h2 id="对象关系映射-ORM"><a href="#对象关系映射-ORM" class="headerlink" title="对象关系映射 ORM"></a>对象关系映射 ORM</h2><p>用于实现面向对象编程语言里不同类型系统的数据之间的转换。数据库表与实体类相对应，数据库表的字段与实体类的属性相对应。减少对 SQL 语句的关注。</p>
<p>MyBatis 和 Hibernate 都是实现 ORM 思想的框架。</p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>MyBatis 中的 SQL 语句和主要业务代码分离，我们一般会把 MyBatis 中的 SQL 语句统一放在 XML 配置文件中，便于统一维护。解偶，提供 DAO 层，系统的设计更清晰，更容易单元测试。</p>
<p>本身就很小且简单，没有任何第三方依赖，易于使用。</p>
<p>MyBatis 屏蔽了原始的 JDBC 样板代码，专注于 SQL 的书写和属性与字段映射上。</p>
<p>MyBatis 最主要的特点就是可以手动编写 SQL 语句，能够支持多表关联查询。</p>
<h1 id="MyBatis-与-Hibernate-对比"><a href="#MyBatis-与-Hibernate-对比" class="headerlink" title="MyBatis 与 Hibernate 对比"></a>MyBatis 与 Hibernate 对比</h1><p>MyBatis 轻量级、上手快、插件丰富，Hibernate 重量级、功能齐全、精通较难。</p>
<p>MyBatis 的 SQL 自由度高，提供灵活的 SQL 编写方式。Hibernate 的 SQL 自由度低，不过也支持手动写 SQL。</p>
<p>MyBatis 开发效率低，需要自己维护 SQL。Hibernate 开发效率高，DAO 层开发简单，支持 JPA。</p>
<p>MyBatis 所以 SQL 都是依赖数据库编写的，需要针对特定数据库维护 SQL。Hibernate 高度解偶，封装了 JDBC，只需要在配置中指定数据库。</p>
<p>MyBatis 自身缓存机制较差，Hibernate 自身缓存机制较好，可避免脏读。</p>
<p>MyBatis 是 POJO 与 SQL 的映射，半 ORM。Hibernate 是 POJO 与数据库的映射，完全 ORM。</p>
<p>MyBatis 性能稍高，Hibernate 的封装方法性能低，Native 方法性能与 MyBatis 差不多。</p>
<p>MyBatis 适合复杂查询，集群间跨数据库事务时。Hibernate 适合单数据库，数据量小，无多表关联，数据库结构不稳定。</p>
<p>这里注明一点：国内使用 MyBatis 的比较多，而国外使用 Hibernate 比较多。</p>
]]></content>
      <tags>
        <tag>backend</tag>
      </tags>
  </entry>
  <entry>
    <title>SimpleDateFormat 类使用避坑</title>
    <url>/2020/05/19/blog7/</url>
    <content><![CDATA[<p>我在参加学校老师手下的一个项目时，负责的云存储套餐这块业务的后端开发，遇到了计算套餐开始和结束时间的问题，并使用了 SimpleDateFormat 类。SimpleDateFormat 是 Java 中使用较多的格式化日期的工具，配合 Calendar 类可以实现时间的计算。</p>
<h2 id="SimpleDateFormat-的使用"><a href="#SimpleDateFormat-的使用" class="headerlink" title="SimpleDateFormat 的使用"></a>SimpleDateFormat 的使用</h2><p>SimpleDateFormat 的构造方法传入想要的日期格式，parse() 将字符串转化为日期，format 则是将日期转化为字符：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SimpleDateFormat simpleDateFormat &#x3D; new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">Date date &#x3D; simpleDateFormat.parse(&quot;2020-05-19 15:06:13&quot;);    &#x2F;&#x2F; Tue May 19 15:06:13 CST 2020</span><br><span class="line">String time &#x3D; simpleDateFormat.format(date);    &#x2F;&#x2F; 2020-05-19 15:06:13</span><br></pre></td></tr></table></figure>

<p>注意 parse() 中当字符串和日期格式 pattern 不一样时，会抛 ParseException。ParseException 属于受检型的异常，需要在 try…catch… 代码块中捕获并进行处理 。</p>
<h2 id="配合-Calendar-完成日期的加减"><a href="#配合-Calendar-完成日期的加减" class="headerlink" title="配合 Calendar 完成日期的加减"></a>配合 Calendar 完成日期的加减</h2><p>Calendar 的 getInstance() 获取 Calendar 实例，setTime() 设置起始时间，add() 进行日期的加减。add() 中 Calendar.DAY_OF_MONTH 表示以天作为计算的单位，Calendar.DATE 也是相同的效果，方法的第二个参数 amount 取负数即可实现减法。如下计算下个月的日期：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SimpleDateFormat simpleDateFormat &#x3D; new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">Date date &#x3D; simpleDateFormat.parse(&quot;2020-05-19 15:06:13&quot;);</span><br><span class="line">Calendar calendar &#x3D; Calendar.getInstance();</span><br><span class="line">calendar.setTime(date);</span><br><span class="line">calendar.add(Calendar.DAY_OF_MONTH, 31);</span><br><span class="line">String endTime &#x3D; simpleDateFormat.format(calendar.getTime());    &#x2F;&#x2F; 2020-06-19 15:06:13</span><br></pre></td></tr></table></figure>

<h2 id="SimpleDateFormat-避坑"><a href="#SimpleDateFormat-避坑" class="headerlink" title="SimpleDateFormat 避坑"></a>SimpleDateFormat 避坑</h2><p><u>重点来惹</u>！一定要按照日期格式的标准写法，比如使用错误的日期格式 “YYYY-MM-dd” 时，format() 将会出现奇怪的日期：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SimpleDateFormat simpleDateFormat &#x3D; new SimpleDateFormat(&quot;YYYY-MM-dd&quot;);</span><br><span class="line">Date date &#x3D; simpleDateFormat.parse(&quot;2020-05-19&quot;);    &#x2F;&#x2F; Sun Dec 29 00:00:00 CST 2019</span><br></pre></td></tr></table></figure>

<p>标准表示日期的字符和其含义：</p>
<table>
<thead>
<tr>
<th align="center">字符</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">yyyy</td>
<td align="center">年</td>
</tr>
<tr>
<td align="center">MM</td>
<td align="center">月</td>
</tr>
<tr>
<td align="center">dd</td>
<td align="center">日</td>
</tr>
<tr>
<td align="center">hh</td>
<td align="center">12小时制</td>
</tr>
<tr>
<td align="center">HH</td>
<td align="center">24小时制</td>
</tr>
<tr>
<td align="center">mm</td>
<td align="center">分</td>
</tr>
<tr>
<td align="center">ss</td>
<td align="center">秒</td>
</tr>
<tr>
<td align="center">S</td>
<td align="center">毫秒</td>
</tr>
<tr>
<td align="center">E</td>
<td align="center">星期几</td>
</tr>
<tr>
<td align="center">D</td>
<td align="center">一年中的第几天</td>
</tr>
<tr>
<td align="center">F</td>
<td align="center">一月中的第几个星期(会把这个月总共过的天数除以7)</td>
</tr>
<tr>
<td align="center">w</td>
<td align="center">一年中的第几个星期</td>
</tr>
<tr>
<td align="center">W</td>
<td align="center">一月中的第几星期(会根据实际情况来算)</td>
</tr>
<tr>
<td align="center">a</td>
<td align="center">上下午标识</td>
</tr>
<tr>
<td align="center">k</td>
<td align="center">和HH差不多，表示24小时制</td>
</tr>
<tr>
<td align="center">K</td>
<td align="center">和hh差不多，表示12小时制</td>
</tr>
<tr>
<td align="center">z</td>
<td align="center">表示时区</td>
</tr>
</tbody></table>
<h2 id="SimpleDateFormat-为什么不是线程安全的？"><a href="#SimpleDateFormat-为什么不是线程安全的？" class="headerlink" title="SimpleDateFormat 为什么不是线程安全的？"></a>SimpleDateFormat 为什么不是线程安全的？</h2><p>额外拓展一个知识点，SimpleDateFormat 不是线程安全的。</p>
<h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>在 SimpleDateFormat 转换日期是通过 Calendar 对象来操作的，SimpleDateFormat 继承 DateFormat 类，DateFormat 类中维护一个 Calendar 对象，Calendar 实例被用来进行日期-时间计算，既被用于 format 方法也被用于 parse 方法。</p>
<p>在 parse 方法的最后，会调用 CalendarBuilder 的 establish 方法，入参就是 SimpleDateFormat 维护的 Calendar 实例，在 establish 方法中会调用 calendar 的 clear 方法。</p>
<p>SimpleDateFormat 维护的用于 format 和 parse 方法计算日期-时间的 calendar 被清空了，如果此时线程 A 将 calendar 清空且没有设置新值，线程 B 也进入 parse 方法用到了 SimpleDateFormat 对象中的 calendar 对象，此时就会产生线程安全问题。</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>每一个使用 SimpleDateFormat 对象进行日期-时间进行 format 和 parse 方法的时候就创建一个新的 SimpleDateFormat 对象，用完就销毁。此时就可以使用 ThreadLocal 将 SimpleDateFormat 绑定到线程上。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>SimpleDateFormat 虽小，但是有坑有拓展点，使用起来还是需要注意的。</p>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL &amp; Redis 技术分享-上</title>
    <url>/2020/05/22/blog8/</url>
    <content><![CDATA[<p>这块内容是 5.9 在项目组做的技术分享，由于是第一次做这种技术分享，组内的也有各种大佬，当时内心激动不已，必须写篇博客记录一下。</p>
<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>首先是后端技术栈介绍，这部分在 <a href="http://www.jiebcoder.top/2020/03/01/blog4/">Java 后端开发技术选型</a> 这篇博客中比较详细的讲述过，主要是计算机网络、操作系统、Spring、分布式、Java、算法和数据库这几部分，引出主题 MySQL &amp; Redis。</p>
<h2 id="MySQL-基础"><a href="#MySQL-基础" class="headerlink" title="MySQL 基础"></a>MySQL 基础</h2><h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><p>先从 MySQL 开始，MySQL 是典型的 C/S 架构，客户端与服务器的连接简单而言就是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Start MySQL Server &amp; mysql -uroot -p</span><br></pre></td></tr></table></figure>

<p>-u 用户名，-p 密码（不建议直接写出来），-h 连接服务器进程所在域名或者 IP 地址（本机则可以忽略），各个参数的摆放顺序没有硬性规定。exit 退出。</p>
<p>然而客户端与服务器的连接到客户端收到服务器处理结果，并没有看起来的那么简单。下图是一次 SQL 查询在 MySQL 客户端与服务器的执行过程：</p>
<img src="/images/blog8/图片1.png" />

<p>可以看到，这个执行过程可以分为连接管理、解析与优化和存储引擎三块。</p>
<h3 id="连接管理"><a href="#连接管理" class="headerlink" title="连接管理"></a>连接管理</h3><p>连接管理中客户端与服务器连接本质上是一个进程间通信的过程，进程的通信方式有：</p>
<ul>
<li>TCP/IP</li>
<li>Windows 下的命名管道或共享内存</li>
<li>Unix 域套接字</li>
</ul>
<p>在客户端程序发起连接的时候，需要携带主机信息、用户名、密码，服务器程序会对客户端程序提供的这些信息进行认证，如果认证失败，服务器程序会拒绝连接。</p>
<p>每当有一个客户端进程连接到服务器进程时，服务器进程都会创建一个线程来专门处理与这个客户端的交互。当该客户端退出时会与服务器断开连接，服务器并不会立即把与该客户端交互的线程销毁掉，而是把它缓存起来，在另一个新的客户端再进行连接时，把这个缓存的线程分配给该新客户端。这就是数据库连接池，这样就起到了不频繁创建和销毁线程的效果，从而节省开销。<br>介绍几款第三方数据库连接池：Apache commons-dbcp（不活跃）、c3p0（很久没有更新）和 Druid（阿里）。</p>
<h3 id="解析与优化"><a href="#解析与优化" class="headerlink" title="解析与优化"></a>解析与优化</h3><p>完成连接的建立后，就进入服务器开始解析与优化。</p>
<h4 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h4><p>首先查询缓存，服务器先检查查询缓存，如果命中了缓存，则立刻返回存储在缓存中的结果。</p>
<p>当判断缓存是否命中时，MySQL 不会进行解析查询语句，而是直接使用 SQL 语句和客户端发送过来的其他原始信息。所以，任何字符上的不同，例如空格、注释等都会导致缓存的不命中。</p>
<p>如果查询请求中包含某些系统函数（同样的函数的两次调用会产生不一样的结果，比如函数 NOW）、用户自定义变量和函数、一些系统表，如 mysql、information_schema、performance_schema 数据库中的表，那这个请求就不会被缓存。当查询语句中有一些不确定的数据时，也则不会被缓存。</p>
<p>查询缓存系统会跟踪查询中涉及的每个表，如果这些表发生了变化，那么和这个表相关的所有缓存数据都将失效。</p>
<p>缓存同时也带来了额外的开销，从 MySQL5.7.20 开始，不推荐使用查询缓存，并在 MySQL8.0 中删除。</p>
<h4 id="语法解析"><a href="#语法解析" class="headerlink" title="语法解析"></a>语法解析</h4><p>从指定的文本中提取出我们需要的信息，本质上算是一个编译过程。</p>
<h4 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h4><p>优化的结果就是生成一个执行计划，这个执行计划表明了应该使用哪些索引进行查询，表之间的连接顺序是什么样的。我们可以使用 EXPLAIN 语句来查看某个语句的执行计划。</p>
<h3 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h3><p>MySQL 服务器把数据的存储和提取操作都封装到了一个叫存储引擎的模块里。我们知道表是由一行一行的记录组成的，但这只是一个逻辑上的概念，物理上如何表示记录，怎么从表中读取数据，怎么把数据写入具体的物理存储器上，这都是存储引擎负责的事情。它的功能就是接收上层传下来的指令，然后对表中的数据进行提取或写入操作。</p>
<p>在 MySQL server 完成了查询优化后，只需按照生成的执行计划调用底层存储引擎提供的 API，获取到数据后返回给客户端就好了。</p>
<p>进入 MySQL 客户端后可以通过：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SHOW ENGINES;</span><br></pre></td></tr></table></figure>

<p>查看 MySQL 支持的存储引擎，如下图：</p>
<img src="/images/blog8/截屏2020-05-22下午5.01.32.png" />

<p>在这些存储引擎中，比较重要的是 InnoDB 和 MyISAM。</p>
<h4 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h4><ul>
<li>MySQL 默认的事务型存储引擎（5.5 版本后），只有在需要它不支持的特性时，才考虑使用其它存储引擎。</li>
<li>实现了四个标准的隔离级别，默认级别是可重复读 REPEATABLE READ。</li>
<li>主索引是聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升</li>
<li>内部优化：从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建的自适应哈希索引、能够加速插入操作的插入缓冲区等。</li>
<li>支持真正的在线热备份，读写混合。其它存储引擎不支持在线热备份。</li>
<li>默认使用行级锁，在无索引无主键情况更新才会锁表。并发度高。</li>
<li>支持外键，MVCC，宕机恢复。</li>
</ul>
<h4 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h4><ul>
<li>设计简单，数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，则依然可以使用它。</li>
<li>支持压缩表（对于不会进行修改的表，极大减少磁盘空间占用）和空间数据索引。</li>
<li>只支持表级锁，不支持行级锁。只能对整张表加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。但在表有读取操作的同时，也可以往表中插入新的记录，这被称为并发插入。</li>
<li>崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢。</li>
<li>如果指定了延迟更新索引 DELAY_KEY_WRITE 选项，在每次修改执行完成时，不会立即将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入磁盘。这种方式可以极大的提升写入性能，但是在数据库或者主机崩溃时会造成索引损坏，需要执行修复操作。</li>
<li>MyISAM 更多强调的是性能，每次查询具有原子性，其执行速度比 InnoDB 更快，但不是绝对的。MyISAM 适合 SELECT 密集型的表。</li>
</ul>
<p>总结下 InnoDB &amp; MyISAM 的主要区别：事务，并发性 InnoDB支持行级锁，InnoDB 还支持外键和在线热备份，并且崩溃恢复优于MyISAM。MyISAM 简单，强调性能，支持压缩表和空间数据索引。</p>
<h3 id="数据库事务"><a href="#数据库事务" class="headerlink" title="数据库事务"></a>数据库事务</h3><p>定义：数据库管理系统执行过程中的一个逻辑单位，由一个有限的数据库操作序列构成。</p>
<h4 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h4><ul>
<li>原子性 Atomicity：事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。回滚日志 undo log 记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。</li>
<li>一致性 Consistency：数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对一个数据的读取结果都是相同的。</li>
<li>隔离性 Isolation：一个事务所做的修改在最终提交以前，对其它事务是不可见的。</li>
<li>持久性 Durability：一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。系统发生奔溃可以用重做日志 redo log 进行恢复，从而实现持久性。与回滚日志记录数据的逻辑修改不同，重做日志记录的是数据页的物理修改。</li>
</ul>
<h4 id="JDBC-实现数据库事务"><a href="#JDBC-实现数据库事务" class="headerlink" title="JDBC 实现数据库事务"></a>JDBC 实现数据库事务</h4><p>JDBC：Java 数据库连接，定义的一套操作所有关系型数据库的接口，不同数据库实现接口，提供 JAR 包。</p>
<p>JDBC 基本操作：</p>
<ol>
<li>注册驱动 DriverManager</li>
<li>获取连接 Connection</li>
<li>开启事务</li>
<li>定义 sql</li>
<li>获取执行 sql 对象 PreparedStatement</li>
<li>执行 sql</li>
<li>事务提交或回滚</li>
<li>释放资源</li>
</ol>
<p>演示代码在 <a href="https://github.com/Jiebupup/demo" target="_blank" rel="noopener">https://github.com/Jiebupup/demo</a> 中有，以转账操作为例，演示了 JDBC 连接等操作和数据库事务。 </p>
<h3 id="log"><a href="#log" class="headerlink" title="log"></a>log</h3><h4 id="bin-log"><a href="#bin-log" class="headerlink" title="bin log"></a>bin log</h4><p>二进制日志，用于记录所有更新且提交了数据或者已经潜在更新提交了数据的所有语句。语句以事件的形式保存，它描述数据更改。</p>
<p>binlog 的作用：</p>
<ul>
<li>恢复时能够最大可能地更新数据库，因为二进制日志包含备份后进行的所有更新。</li>
<li>在主复制服务器上记录所有将发送给从服务器的语句。在后面将介绍的主从复制中会有。</li>
</ul>
<h4 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h4><p>回滚日志，实现事务的原子性。在 InnoDB 中还用 undo log 来实现 MVCC。</p>
<p>在操作任何数据之前，首先将数据备份到 undo log。然后进行数据的修改。如果出现了错误或者用户执行了 ROLLBACK 语句，系统可以利用 undo log 中的备份将数据恢复到事务开始之前的状态。<br>除了可以保证事务的原子性，undo log 也可以用来辅助完成事务的持久化。</p>
<p>缺陷：每个事务提交前将数据和 undo log 写入磁盘，这样会导致大量的磁盘 I/O，因此性能很低。</p>
<h4 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h4><p>重做日志，记录新数据的备份。在事务提交前，只要将 redo log 持久化即可，不需要将数据持久化。</p>
<p>当系统崩溃时，虽然数据没有持久化，但是 redo log 已经持久化。系统可以根据 redo log 的内容，将所有数据恢复到最新的状态。</p>
<p>redo log 包括两部分：</p>
<ul>
<li>一是内存中的日志缓冲 buffer，该部分日志是易失性的。</li>
<li>二是磁盘上的重做日志文件 file，该部分日志是持久的。</li>
</ul>
<h3 id="并发一致性问题"><a href="#并发一致性问题" class="headerlink" title="并发一致性问题"></a>并发一致性问题</h3><ul>
<li>丢失修改：T1 和 T2 两个事务都对一个数据进行修改，T1 先修改，T2 随后修改，T2 的修改覆盖了 T1 的修改。</li>
<li>读脏数据：T1 修改一个数据，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据。</li>
<li>不可重复读：T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。</li>
<li>幻读：T1 读取某个范围（多行）的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。</li>
</ul>
<p>并发一致性问题从上到下一致性问题越来越严重。</p>
<h3 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h3><ul>
<li>未提交读 READ UNCOMMITTED：事务中的修改，即使没有提交，对其它事务也是可见的。</li>
<li>提交读 READ COMMITTED：一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。大部分数据库系统的隔离级别都是 READ COMMITTED。</li>
<li>可重复读 REPEATABLE READ：保证在同一个事务中多次读取同样数据的结果是一样的。MySQL 默认是 REPEATABLE READ。通过 MVCC + Next-Key Locks 防止幻读。</li>
<li>可串行化 SERIALIZABLE：强制事务串行执行，这样多个事务互不干扰，不会出现并发一致性问题。需要加锁实现，保证同一时间只有一个事务执行。</li>
</ul>
<p>对应隔离级别解决并发一致性问题。如图：</p>
<img src="/images/blog8/图片2.png" />

<h3 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h3><p>多版本并发控制 MVCC 是 InnoDB 存储引擎实现隔离级别的一种具体方式，用于实现提交读和可重复读这两种隔离级别。</p>
<p>加锁能解决多个事务同时执行时出现的并发一致性问题。在实际场景中读操作往往多于写操作。<br>读写锁能避免不必要的加锁操作，例如读和读没有互斥关系。但读写锁中读和写操作仍然是互斥的。<br>MVCC 利用了多版本的思想，写操作更新最新的版本快照，而读操作去读旧版本快照，没有互斥关系。</p>
<p>前面讲到脏读和不可重复读最根本的原因是事务读取到其它事务未提交的修改。在事务进行读取操作时，为了解决脏读和不可重复读问题，MVCC 规定只能读取已经提交的快照。</p>
<p>又分为：快照读和当前读。<br>快照读：MVCC 的 SELECT 操作是快照中的数据，不需要进行加锁操作。<br>当前读：MVCC 会对 INSERT、UPDATE、DELETE 进行加锁操作，从而读取最新的数据。可以看到 MVCC 并不是完全不用加锁，而只是避免了 SELECT 的加锁操作。</p>
<p>用 undo log 来实现 MVCC：undo log 用来记录版本快照。<br>MVCC 的多版本指的是多个版本的快照，快照存储在 undo log 中，该日志通过回滚指针 ROLL_PTR 把一个数据行的所有快照连接起来。<br>INSERT、UPDATE、DELETE 操作会创建一个日志，并将事务版本号 TRX_ID 写入。DELETE 可以看成是一个特殊的 UPDATE，此时还会额外将 DEL 字段设置为 1。</p>
<h3 id="Next-Key-Locks"><a href="#Next-Key-Locks" class="headerlink" title="Next-Key Locks"></a>Next-Key Locks</h3><p>可重复读下防止幻读，光 MVCC 是不够的，还需要间隙锁。</p>
<p>MySQL 中提供了两种封锁粒度：行级锁以及表级锁。</p>
<p>读写锁：</p>
<ul>
<li>写锁，又称排它锁，简写为 X 锁。</li>
<li>读锁，又称共享锁，简写为 S 锁。都是读时不会互斥。</li>
</ul>
<p>InnoDB 行锁是通过给索引上的索引项加锁来实现的。锁粒度小，锁冲突发生的概率最低，支持的并发度也最高。<br>但系统消耗成本也相对较高。加锁慢，会出现死锁。<br>行锁又分为：Record 、Gap 和 Next-Key。</p>
<ul>
<li>Record Locks：锁定一个记录上的索引，而不是记录本身。如果表没有设置索引，InnoDB 会自动在主键上创建隐藏的聚簇索引，因此 Record Locks 依然可以使用。</li>
<li>Gap Locks：锁定索引之间的间隙，但是不包含索引本身。</li>
<li>Next-Key Locks：是 Record Locks 和 Gap Locks 的结合，不仅锁定一个记录上的索引，也锁定索引之间的间隙。Next-Key Locks锁定一个左开右闭区间。<br>当查询的索引含有唯一属性时，将 Next-Key Locks 降级为 Record Locks。</li>
</ul>
<p>除了行级锁和表级锁，BDB 这个数据库还支持页锁，介于两者之间。</p>
<p>结合刚才讲到 MVCC 和 Next-Key Locks，在可重复读下防止幻读，因为间隙锁锁住了间隙，MVCC 进行正常的快照读。</p>
<h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>B+ Tree 索引：</p>
<img src="/images/blog8/图片3.png" />

<p>B+ Tree 是查找树，所有叶子节点位于同一层且包含了全部元素的信息，叶子节点用顺序访问指针连接。所有的中间节点元素都同时存在于子节点中，在子节点元素中是最大或最小的元素。</p>
<p>哈希索引：能以 O(1) 时间进行查找，但是失去了有序性。<br>自适应哈希索引：InnoDB 当某个索引值被使用的非常频繁时，会在 B+ Tree 索引之上再创建一个哈希索引，具备哈希快速查找的功能。</p>
<p>MyISAM 支持全文索引和空间数据索引，InnoDB 在 MySQL 5.6.4 版本中也开始支持全文索引。</p>
<h4 id="InnoDB-的-B-Tree-索引"><a href="#InnoDB-的-B-Tree-索引" class="headerlink" title="InnoDB 的 B+ Tree 索引"></a>InnoDB 的 B+ Tree 索引</h4><p>主索引的叶子节点 data 域记录着完整的数据记录，这种索引方式被称为聚簇索引。因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。</p>
<img src="/images/blog8/图片4.png" />

<p>辅助索引的叶子节点的 data 域记录着主键的值，因此在使用辅助索引进行查找时，需要先查找到主键值，然后再到主索引中进行查找。</p>
<img src="/images/blog8/图片5.png" />

<h2 id="MySQL-高级特性"><a href="#MySQL-高级特性" class="headerlink" title="MySQL 高级特性"></a>MySQL 高级特性</h2><h3 id="切分"><a href="#切分" class="headerlink" title="切分"></a>切分</h3><h4 id="水平切分"><a href="#水平切分" class="headerlink" title="水平切分"></a>水平切分</h4><p>水平切分又叫 Sharding，将同一个表中的记录按行拆分到多个结构相同的表中，每个库的表结构都一样，只不过每个库表放的数据是不同的。当一个表的数据不断增多时，Sharding 是必然的选择，它可以将数据分布到集群的不同节点上，从而缓解单个数据库的压力，达到分布式的目的。</p>
<h4 id="垂直切分"><a href="#垂直切分" class="headerlink" title="垂直切分"></a>垂直切分</h4><p>垂直切分将一张表按列切分成多个表，因为数据库是有缓存的，你访问频率高的行字段越少，就可以在缓存里缓存更多的行，性能就越好。</p>
<h4 id="数据库中间件"><a href="#数据库中间件" class="headerlink" title="数据库中间件"></a>数据库中间件</h4><p>数据库中间件用来分库分表。分为客户端和代理端。</p>
<ul>
<li>客户端：分片逻辑在应用端，封装在 JAR 包中，通过修改或者封装 JDBC 层来实现。如 Sharding-JDBC。</li>
<li>代理端：在应用和数据中间加了一个代理层。分片逻辑统一维护在中间件服务层中。如 MyCAT。</li>
</ul>
<h3 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h3><h4 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h4><ul>
<li>binlog 线程：在主库上把数据更改记录到二进制日志中。</li>
<li>I/O 线程：备库读取二进制日志并写入到自己的中继日志中。</li>
<li>SQL 线程：备库读取中继日志，解析出主库已经执行的数据更改并在从备库中重放。</li>
</ul>
<h4 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h4><p>主库负责写，从库负责读，避免了同一个库读写加锁，同时也体现了高可用性。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>由于分享内容过多，我使用上下两篇博客的形式，本篇讲述了 MySQL。下一篇将会记录 Redis 相关的内容。</p>
]]></content>
      <tags>
        <tag>backend</tag>
      </tags>
  </entry>
</search>
