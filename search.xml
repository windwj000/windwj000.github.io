<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java 实现支付宝后台支付接口</title>
    <url>/blog11/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>项目中需要对商品订单进行支付，这里记录下自己是如何使用 Java 实现支付宝后台支付接口，支付操作为 App 支付。</p>
<p>官方文档：<a href="https://opendocs.alipay.com/open/204/105297" target="_blank" rel="noopener">https://opendocs.alipay.com/open/204/105297</a> 。</p>
<h2 id="编码前的准备"><a href="#编码前的准备" class="headerlink" title="编码前的准备"></a>编码前的准备</h2><p>1.<strong>创建应用</strong></p>
<p>在支付宝开放平台的开发者中心，创建自己的应用，并取得应用的唯一标识 APPID。</p>
<p>2.<strong>添加支付能力</strong></p>
<p>在应用详情页面，添加能力-App 支付，并进行签约。</p>
<p>3.<strong>密钥生成和配置</strong></p>
<p>为了保障交易身份与数据的安全，需要进行密钥的配置，这里由于是企业的项目，需要配置公钥证书，这里需要用到支付宝开放平台开发助手，生成 CSR 文件：应用公钥、私钥、证书这 3 个文件。详见官网文档：<a href="https://opendocs.alipay.com/open/291/105971" target="_blank" rel="noopener">https://opendocs.alipay.com/open/291/105971</a> 。</p>
<p>然后需要在应用的开发信息中，设置接口加签方式，上传 CSR 文件，在线生成应用公钥证书即 .crt 文件，然后上传这个证书。上传完成后，还可以下载对应的支付宝公钥证书和支付宝根证书。</p>
<p>4.<strong>后台集成支付宝的 SDK</strong></p>
<p>这个 SDK 用于协助解析并验证客户端同步返回的支付结果和异步通知。</p>
<p>App 端也需要集成支付宝对应的 SDK。</p>
<h2 id="编写支付接口"><a href="#编写支付接口" class="headerlink" title="编写支付接口"></a>编写支付接口</h2><h3 id="支付宝支付流程图"><a href="#支付宝支付流程图" class="headerlink" title="支付宝支付流程图"></a>支付宝支付流程图</h3><img src="/images/blog11/alipay.png" width="80%"/>

<h3 id="在-App-端的表现"><a href="#在-App-端的表现" class="headerlink" title="在 App 端的表现"></a>在 App 端的表现</h3><p>用户在 App 上点击立即购买，选择支付方式，点击确定支付调用后台接口并跳转到支付宝 App，付款完成后，跳转回 App，完成支付。</p>
<h3 id="后台接口的需求"><a href="#后台接口的需求" class="headerlink" title="后台接口的需求"></a>后台接口的需求</h3><p>后台需要提供 3 个接口：订单信息加密、支付宝服务端异步通知、最终付款校验。</p>
<h3 id="接口-1：订单信息加密"><a href="#接口-1：订单信息加密" class="headerlink" title="接口 1：订单信息加密"></a><strong>接口 1：订单信息加密</strong></h3><p><strong>功能</strong></p>
<p>传入订单信息，返回加密后的订单字符串，并在项目数据库保存支付宝订单信息。</p>
<p><strong>密钥验证方式</strong></p>
<p>支付宝客户端将传送的消息用私钥加密，服务端使用公钥对消息进行验证。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(value = <span class="string">"/encrypt"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> AjaxResult <span class="title">getAliPayOrder</span><span class="params">(@RequestParam String orderSn)</span> <span class="keyword">throws</span> AlipayApiException </span>&#123;</span><br><span class="line">  </span><br><span class="line">    EOrder eOrder=eOrderService.selectEOrderByOrderSn(orderSn);</span><br><span class="line"></span><br><span class="line">    AlipaymentOrder alipaymentOrder = <span class="keyword">new</span> AlipaymentOrder();</span><br><span class="line">    alipaymentOrder.setOrderId(eOrder.getOrderId().intValue());</span><br><span class="line">    alipaymentOrder.setOutTradeNo(orderSn);</span><br><span class="line">    alipaymentOrder.setAmount(eOrder.getActualPrice());</span><br><span class="line">    <span class="comment">// 订单生成，等待用户付款</span></span><br><span class="line">    alipaymentOrder.setTradeStatus(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造client</span></span><br><span class="line">    CertAlipayRequest certAlipayRequest = <span class="keyword">new</span> CertAlipayRequest();</span><br><span class="line">    <span class="comment">//设置网关地址</span></span><br><span class="line">    certAlipayRequest.setServerUrl(<span class="string">"https://openapi.alipay.com/gateway.do"</span>);</span><br><span class="line">    <span class="comment">//设置应用Id</span></span><br><span class="line">    certAlipayRequest.setAppId(app_id);</span><br><span class="line">    <span class="comment">//设置应用私钥</span></span><br><span class="line">    certAlipayRequest.setPrivateKey(privateKey);</span><br><span class="line">    <span class="comment">//设置请求格式，固定值json</span></span><br><span class="line">    certAlipayRequest.setFormat(<span class="string">"json"</span>);</span><br><span class="line">    <span class="comment">//设置字符集</span></span><br><span class="line">    certAlipayRequest.setCharset(<span class="string">"UTF-8"</span>);</span><br><span class="line">    <span class="comment">//设置签名类型</span></span><br><span class="line">    certAlipayRequest.setSignType(<span class="string">"RSA2"</span>);</span><br><span class="line">    <span class="comment">//设置应用公钥证书路径</span></span><br><span class="line">    certAlipayRequest.setCertPath(certPath);</span><br><span class="line">    <span class="comment">//设置支付宝公钥证书路径</span></span><br><span class="line">    certAlipayRequest.setAlipayPublicCertPath(alipayPublicCertPath);</span><br><span class="line">    <span class="comment">//设置支付宝根证书路径</span></span><br><span class="line">    certAlipayRequest.setRootCertPath(rootCertPath);</span><br><span class="line">    <span class="comment">//构造client</span></span><br><span class="line">    AlipayClient alipayClient = <span class="keyword">new</span> DefaultAlipayClient(certAlipayRequest);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//实例化具体API对应的request类,类名称和接口名称对应,当前调用接口名称：alipay.trade.app.pay</span></span><br><span class="line">    AlipayTradeAppPayRequest request = <span class="keyword">new</span> AlipayTradeAppPayRequest();</span><br><span class="line">    <span class="comment">//SDK已经封装掉了公共参数，这里只需要传入业务参数。以下方法为sdk的model入参方式(model和biz_content同时存在的情况下取biz_content)。</span></span><br><span class="line">    AlipayTradeAppPayModel model = <span class="keyword">new</span> AlipayTradeAppPayModel();</span><br><span class="line">    model.setBody(<span class="string">"xx"</span>);</span><br><span class="line">    model.setSubject(<span class="string">"xx"</span>);</span><br><span class="line">    model.setOutTradeNo(orderSn);</span><br><span class="line">    model.setTimeoutExpress(<span class="string">"30m"</span>);</span><br><span class="line">    model.setTotalAmount(eOrder.getActualPrice().toString());</span><br><span class="line">    model.setProductCode(<span class="string">"QUICK_MSECURITY_PAY"</span>);</span><br><span class="line">    request.setBizModel(model);</span><br><span class="line">    <span class="comment">// 需要外网需要能直接访问的地址</span></span><br><span class="line">    request.setNotifyUrl(<span class="string">"xxx"</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//这里和普通的接口调用不同，使用的是sdkExecute</span></span><br><span class="line">        AlipayTradeAppPayResponse response = alipayClient.sdkExecute(request);</span><br><span class="line">        <span class="comment">// 如果未发生异常，则记录支付宝订单</span></span><br><span class="line">        alipaymentOrderService.insertAlipaymentOrder(alipaymentOrder);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> AjaxResult.success(response.getBody());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (AlipayApiException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> AjaxResult.error(<span class="string">"加密失败！"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>入参 orderSn 是订单编号，这里需要在项目后台数据库保存支付宝支付订单，使用 AlipaymentOrder 这个实体类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AlipaymentOrder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 订单ID</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> orderId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 订单号</span></span><br><span class="line">    <span class="keyword">private</span> String outTradeNo;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 金额</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> amount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 交易状态</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tradeStatus;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通知时间</span></span><br><span class="line">    <span class="keyword">private</span> String notifyTime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 订单生成时间</span></span><br><span class="line">    <span class="keyword">private</span> String createTime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 付款时间</span></span><br><span class="line">    <span class="keyword">private</span> String payTime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 退款时间</span></span><br><span class="line">    <span class="keyword">private</span> String refundTime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 订单结束时间</span></span><br><span class="line">    <span class="keyword">private</span> String closeTime;</span><br><span class="line">  </span><br><span class="line"> 		...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是 response.getBody() 就是加密后的订单字符串，可以直接返回给 App 端进行使用。</p>
<h3 id="接口-2：支付宝服务端异步通知"><a href="#接口-2：支付宝服务端异步通知" class="headerlink" title="接口 2：支付宝服务端异步通知"></a>接口 2：支付宝服务端异步通知</h3><p><strong>功能</strong></p>
<ul>
<li><p>通过异步通知更新支付宝订单信息。</p>
</li>
<li><p>防止订单丢失，即页面跳转同步通知没有处理订单更新，它则去处理。</p>
</li>
</ul>
<p><strong>注意</strong></p>
<ul>
<li>只有在支付宝的交易管理中存在该笔交易，且发生了交易状态的改变，支付宝才会通过该方式发起服务器通知。</li>
<li>第一次交易状态改变（即时到账中此时交易状态是交易完成）时，不仅会返回同步处理结果，而且服务器异步通知页面也会收到支付宝发来的处理结果通知。</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(value = <span class="string">"/asyn"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getAsynResult</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> AlipayApiException </span>&#123;</span><br><span class="line">  <span class="comment">//获取支付宝POST过来反馈信息</span></span><br><span class="line">  Map&lt;String,String&gt; params = <span class="keyword">new</span> HashMap&lt;String,String&gt;();</span><br><span class="line">  Map requestParams = request.getParameterMap();</span><br><span class="line">  <span class="keyword">for</span> (Iterator iter = requestParams.keySet().iterator(); iter.hasNext();) &#123;</span><br><span class="line">    String name = (String) iter.next();</span><br><span class="line">    String[] values = (String[]) requestParams.get(name);</span><br><span class="line">    String valueStr = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; values.length; i++) &#123;</span><br><span class="line">      valueStr = (i == values.length - <span class="number">1</span>) ? valueStr + values[i]</span><br><span class="line">        : valueStr + values[i] + <span class="string">","</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//乱码解决，这段代码在出现乱码时使用。</span></span><br><span class="line">    <span class="comment">//valueStr = new String(valueStr.getBytes("ISO-8859-1"), "utf-8");</span></span><br><span class="line">    params.put(name, valueStr);</span><br><span class="line">    logger.info(name+<span class="string">" "</span>+valueStr);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//切记alipaypublickey是支付宝的公钥，请去open.alipay.com对应应用下查看。</span></span><br><span class="line">  <span class="comment">//boolean AlipaySignature.rsaCertCheckV1(Map&lt;String, String&gt; params, String publicKeyCertPath, String charset,String signType)</span></span><br><span class="line">  <span class="comment">//调用SDK验证签名</span></span><br><span class="line">  <span class="keyword">boolean</span> flag = AlipaySignature.rsaCertCheckV1(params, alipayPublicCertPath, <span class="string">"UTF-8"</span>,<span class="string">"RSA2"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">    <span class="comment">//获取商户之前传给支付宝的订单号（商户系统的唯一订单号）</span></span><br><span class="line">    String outTradeNo = params.get(<span class="string">"out_trade_no"</span>);</span><br><span class="line">    <span class="comment">//订单金额:本次交易支付的订单金额，单位为人民币（元）</span></span><br><span class="line">    String totalAmount=params.get(<span class="string">"total_amount"</span>);</span><br><span class="line">    <span class="comment">//卖家支付宝用户号</span></span><br><span class="line">    String sellerId=params.get(<span class="string">"seller_id"</span>);</span><br><span class="line">    <span class="comment">//支付宝分配给开发者的应用Id</span></span><br><span class="line">    String appId=params.get(<span class="string">"app_id"</span>);</span><br><span class="line">    <span class="comment">//获取交易状态</span></span><br><span class="line">    String tradeStatus = params.get(<span class="string">"trade_status"</span>);</span><br><span class="line">    <span class="comment">//通知时间:yyyy-MM-dd HH:mm:ss</span></span><br><span class="line">    String notifyTime=params.get(<span class="string">"notify_time"</span>);</span><br><span class="line">    <span class="comment">//交易创建时间:yyyy-MM-dd HH:mm:ss</span></span><br><span class="line">    String gmtCreate=params.get(<span class="string">"gmt_create"</span>);</span><br><span class="line">    <span class="comment">//交易付款时间</span></span><br><span class="line">    String gmtPayment=params.get(<span class="string">"gmt_payment"</span>);</span><br><span class="line">    <span class="comment">//交易退款时间</span></span><br><span class="line">    String gmtRefund=params.get(<span class="string">"gmt_refund"</span>);</span><br><span class="line">    <span class="comment">//交易结束时间</span></span><br><span class="line">    String gmtClose=params.get(<span class="string">"gmt_close"</span>);</span><br><span class="line"></span><br><span class="line">    AlipaymentOrder alipaymentOrder = alipaymentOrderService.selectAlipaymentOrder(outTradeNo);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//支付宝官方建议校验的值（out_trade_no、total_amount、sellerId、app_id）</span></span><br><span class="line">    <span class="keyword">if</span> (alipaymentOrder != <span class="keyword">null</span> &amp;&amp; totalAmount.equals(String.valueOf(alipaymentOrder.getAmount())) &amp;&amp; app_id.equals(appId)) &#123;</span><br><span class="line">      <span class="comment">// 更新时间相关的值</span></span><br><span class="line">      alipaymentOrder.setNotifyTime(notifyTime);</span><br><span class="line">      alipaymentOrder.setCreateTime(gmtCreate);</span><br><span class="line">      alipaymentOrder.setPayTime(gmtPayment);</span><br><span class="line">      alipaymentOrder.setRefundTime(gmtRefund);</span><br><span class="line">      alipaymentOrder.setCloseTime(gmtClose);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 判断交易结果</span></span><br><span class="line">      <span class="keyword">switch</span> (tradeStatus)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"TRADE_FINISHED"</span>: <span class="comment">// 交易结束并不可退款</span></span><br><span class="line">          alipaymentOrder.setTradeStatus(<span class="number">3</span>);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"TRADE_SUCCESS"</span>: <span class="comment">// 交易支付成功</span></span><br><span class="line">          alipaymentOrder.setTradeStatus(<span class="number">2</span>);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"TRADE_CLOSED"</span>: <span class="comment">// 未付款交易超时关闭或支付完成后全额退款</span></span><br><span class="line">          alipaymentOrder.setTradeStatus(<span class="number">1</span>);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"WAIT_BUYER_PAY"</span>: <span class="comment">// 交易创建并等待买家付款</span></span><br><span class="line">          alipaymentOrder.setTradeStatus(<span class="number">0</span>);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      alipaymentOrderService.updateAlipaymentOrder(alipaymentOrder);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (tradeStatus.equals(<span class="string">"TRADE_SUCCESS"</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//                return AjaxResult.success("验证签名成功但订单未成功支付");</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//            return AjaxResult.error("支付宝官方建议校验的值（out_trade_no、total_amount、sellerId、app_id）不一致！");</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//        return AjaxResult.error("验证签名失败！");</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">"fail"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意按照支付宝要求，返回的必须是字符串 “success” 或 “fail”。</p>
<h3 id="接口-3：最终付款校验"><a href="#接口-3：最终付款校验" class="headerlink" title="接口 3：最终付款校验"></a>接口 3：最终付款校验</h3><p><strong>功能</strong></p>
<p>最终支付结果必须通过这个接口进行校验。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(value = <span class="string">"/check"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> AjaxResult <span class="title">check</span><span class="params">(@RequestParam String outTradeNo)</span> <span class="keyword">throws</span> AlipayApiException, ParseException </span>&#123;</span><br><span class="line">    <span class="comment">//构造client</span></span><br><span class="line">    CertAlipayRequest certAlipayRequest = <span class="keyword">new</span> CertAlipayRequest();</span><br><span class="line">    <span class="comment">//设置网关地址</span></span><br><span class="line">    certAlipayRequest.setServerUrl(<span class="string">"https://openapi.alipay.com/gateway.do"</span>);</span><br><span class="line">    <span class="comment">//设置应用Id</span></span><br><span class="line">    certAlipayRequest.setAppId(app_id);</span><br><span class="line">    <span class="comment">//设置应用私钥</span></span><br><span class="line">    certAlipayRequest.setPrivateKey(privateKey);</span><br><span class="line">    <span class="comment">//设置请求格式，固定值json</span></span><br><span class="line">    certAlipayRequest.setFormat(<span class="string">"json"</span>);</span><br><span class="line">    <span class="comment">//设置字符集</span></span><br><span class="line">    certAlipayRequest.setCharset(<span class="string">"UTF-8"</span>);</span><br><span class="line">    <span class="comment">//设置签名类型</span></span><br><span class="line">    certAlipayRequest.setSignType(<span class="string">"RSA2"</span>);</span><br><span class="line">    <span class="comment">//设置应用公钥证书路径</span></span><br><span class="line">    certAlipayRequest.setCertPath(certPath);</span><br><span class="line">    <span class="comment">//设置支付宝公钥证书路径</span></span><br><span class="line">    certAlipayRequest.setAlipayPublicCertPath(alipayPublicCertPath);</span><br><span class="line">    <span class="comment">//设置支付宝根证书路径</span></span><br><span class="line">    certAlipayRequest.setRootCertPath(rootCertPath);</span><br><span class="line">    <span class="comment">//构造client</span></span><br><span class="line">    AlipayClient alipayClient = <span class="keyword">new</span> DefaultAlipayClient(certAlipayRequest);</span><br><span class="line"></span><br><span class="line">    AlipayTradeQueryRequest alipayTradeQueryRequest = <span class="keyword">new</span> AlipayTradeQueryRequest();</span><br><span class="line">    alipayTradeQueryRequest.setBizContent(<span class="string">"&#123;"</span> +</span><br><span class="line">            <span class="string">"\"out_trade_no\":\""</span>+outTradeNo+<span class="string">"\""</span> +</span><br><span class="line">            <span class="string">"&#125;"</span>);</span><br><span class="line"></span><br><span class="line">    AlipayTradeQueryResponse alipayTradeQueryResponse = alipayClient.certificateExecute(alipayTradeQueryRequest);</span><br><span class="line">    <span class="keyword">if</span>(alipayTradeQueryResponse.isSuccess())&#123;</span><br><span class="line">        AlipaymentOrder alipaymentOrder=alipaymentOrderService.selectAlipaymentOrder(outTradeNo);</span><br><span class="line">        EOrder eOrder=eOrderService.selectEOrderByOrderSn(outTradeNo);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//修改数据库支付宝订单表</span></span><br><span class="line">        alipaymentOrder.setAmount(Double.parseDouble(alipayTradeQueryResponse.getTotalAmount()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断交易结果</span></span><br><span class="line">        <span class="keyword">switch</span> (alipayTradeQueryResponse.getTradeStatus())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"TRADE_FINISHED"</span>: <span class="comment">// 交易结束并不可退款</span></span><br><span class="line">                alipaymentOrder.setTradeStatus(<span class="number">3</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"TRADE_SUCCESS"</span>: <span class="comment">// 交易支付成功</span></span><br><span class="line">                alipaymentOrder.setTradeStatus(<span class="number">2</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"TRADE_CLOSED"</span>: <span class="comment">// 未付款交易超时关闭或支付完成后全额退款</span></span><br><span class="line">                alipaymentOrder.setTradeStatus(<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"WAIT_BUYER_PAY"</span>: <span class="comment">// 交易创建并等待买家付款</span></span><br><span class="line">                alipaymentOrder.setTradeStatus(<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        alipaymentOrderService.updateAlipaymentOrder(alipaymentOrder);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果支付成功，更新订单</span></span><br><span class="line">        <span class="keyword">if</span>(alipayTradeQueryResponse.getTradeStatus()==<span class="string">"TRADE_SUCCESS"</span>)&#123;</span><br><span class="line">            eOrder.setOrderStatus(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            String payTime=alipaymentOrder.getPayTime();</span><br><span class="line">            SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">            Date date=simpleDateFormat.parse(payTime);</span><br><span class="line">            eOrder.setPayTime(date);</span><br><span class="line"></span><br><span class="line">            eOrderMapper.updateEOrder(eOrder);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 保险订单</span></span><br><span class="line">            <span class="keyword">if</span> (eOrder.getOrderType() == <span class="number">1</span>) &#123;</span><br><span class="line">                EInsuranceOrder eInsuranceOrder=eInsuranceOrderMapper.selectEInsuranceOrderByOrderSn(outTradeNo);</span><br><span class="line">                eInsuranceOrder.setOrderStatus(<span class="number">1</span>);</span><br><span class="line">                eInsuranceOrder.setPayTime(date);</span><br><span class="line"></span><br><span class="line">                eInsuranceOrderMapper.updateEInsuranceOrder(eInsuranceOrder);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> AjaxResult.success(alipaymentOrder);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> AjaxResult.error(<span class="string">"调用支付宝查询接口失败！"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个接口可以加上支付成功后的订单逻辑。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这类通过第三方接口进行开发的工作，基本流程也就是上述这样，主要问题还是出在官方文档与实际操作的不符，这就需要 1.仔细阅读官方文档和理解示例代码 2.多打断点调试和看日志的输出情况。</p>
<p>比较重要的点是要和自己项目的业务逻辑结合，知道该把自己的代码安插在哪个位置。</p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="https://blog.csdn.net/Ouyzc/article/details/79551714" target="_blank" rel="noopener">https://blog.csdn.net/Ouyzc/article/details/79551714</a></p>
]]></content>
      <categories>
        <category>backend</category>
      </categories>
  </entry>
  <entry>
    <title>欢迎来到我的网站</title>
    <url>/blog1/</url>
    <content><![CDATA[<p>欢迎各位!</p>
<p>本网站用于记录我日常编程与开发的心得体会，主要但不限于 Java 后端开发方向。</p>
<p>这是本网站的第一篇博客，以后我会以学习和分享为目的，用心产出高质量的技术博客，希望能和大家多多交流，共同进步。</p>
]]></content>
      <categories>
        <category>welcome</category>
      </categories>
  </entry>
  <entry>
    <title>Spring bean 的声明和注入</title>
    <url>/blog10/</url>
    <content><![CDATA[<p>Spring bean 就是可重用组件，是 Spring 的基础。</p>
<p>通过 @Component 注解将一个类声明为 bean，交给 Spring 管理，并在需要的时候注入获取实例。这就是 Spring 重要的 IOC 功能。</p>
<p>今天研究的问题出现在<strong><u>注入</u></strong>这一步：在对一个工具类注入 RedisCache（封装了 RedisTemplate 的工具类），由于工具类使用了静态方法，导致无法获取到注入的 RedisCache。</p>
<h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><p>首先来认识一下 static 可以作用的对象：</p>
<h4 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h4><p>又称为类变量，也就是说这个变量属于类的，类所有的实例都共享静态变量，可以直接通过类名来访问它。静态变量在内存中只存在一份。当类被 Java 虚拟机加载的时候，会对 static 变量进行初始化。静态变量存放在 Java 内存区域的方法区。而实例变量每创建一个实例就会产生一个，它与该实例同生共死。</p>
<h4 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h4><p>在类加载的时候就存在了，它不依赖于任何实例。所以静态方法必须有实现，也就是说它不能是抽象方法。只能访问所属类的静态字段和静态方法（初始化顺序），方法中不能有 this 和 super 关键字（静态不需要对象）。调用静态方法可以无需创建对象（如果使用对象.静态方法会在编译后翻译为类.静态方法）。如果方法执行的操作不依赖于其类的各个变量和方法，设置为静态使程序的占用空间更小。</p>
<h4 id="静态语句块"><a href="#静态语句块" class="headerlink" title="静态语句块"></a>静态语句块</h4><p>静态代码块定义在类中方法外，静态代码块在非静态代码块之前执行。该类不管创建多少对象，在类初始化时运行一次。</p>
<h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h4><p>非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围类，但是静态内部类却没有。非静态内部类依赖于外部类的实例，也就是说需要先创建外部类实例，才能用这个实例去创建非静态内部类。而静态内部类不需要。静态内部类不能访问外部类的非静态的变量和方法。</p>
<h4 id="静态导包"><a href="#静态导包" class="headerlink" title="静态导包"></a>静态导包</h4><p>JDK1.5</p>
<p>我们这里使用的是<u><strong>静态方法</strong></u>，属于类，而不属于某个实例，调用静态方法时不会创建对象。</p>
<p>静态方法还提到了初始化顺序：</p>
<h4 id="初始化顺序"><a href="#初始化顺序" class="headerlink" title="初始化顺序"></a>初始化顺序</h4><p>静态变量和静态语句块 -&gt; 实例变量和普通语句块 -&gt; 构造函数。静态变量和静态语句块的初始化顺序取决于它们在代码中的顺序。</p>
<p><strong>存在继承时的初始化顺序</strong></p>
<ol>
<li><p>父类（静态变量、静态语句块）</p>
</li>
<li><p>子类（静态变量、静态语句块）</p>
</li>
<li><p>父类（实例变量、普通语句块）</p>
</li>
<li><p>父类（构造函数）</p>
</li>
<li><p>子类（实例变量、普通语句块）</p>
</li>
<li><p>子类（构造函数）</p>
</li>
</ol>
<h3 id="bean-的声明"><a href="#bean-的声明" class="headerlink" title="bean 的声明"></a>bean 的声明</h3><p>共有四种方式将将一个<u><strong>类</strong></u>声明为 bean 的注解：</p>
<h4 id="Component"><a href="#Component" class="headerlink" title="@Component"></a>@Component</h4><p>通用的注解，可标注任意类为 Spring 组件。如果一个 bean 不知道属于哪个层，可以使用 @Component 注解标注。创建对象，把当前对象存入 Spring 容器中，相当于 XML 的 &lt; bean&gt;。</p>
<h4 id="Repository"><a href="#Repository" class="headerlink" title="@Repository"></a>@Repository</h4><p>对应持久层，主要用于数据库相关操作。</p>
<h4 id="Service"><a href="#Service" class="headerlink" title="@Service"></a>@Service</h4><p>对应服务层，主要涉及一些复杂的逻辑。</p>
<h4 id="Controller"><a href="#Controller" class="headerlink" title="@Controller"></a>@Controller</h4><p>对应控制层，主要用户接受用户请求并返回数据给前端页面。</p>
<p>@Bean 注解作用于<u><strong>方法</strong></u>，对比一下 @Component ：</p>
<h4 id="Component-和-Bean-的区别"><a href="#Component-和-Bean-的区别" class="headerlink" title="@Component 和 @Bean 的区别"></a>@Component 和 @Bean 的区别</h4><p>@Component 注解作用于类，而 @Bean 注解作用于方法。</p>
<p>@Component 通常是通过类路径扫描来自动侦测以及自动装配到 Spring 容器中，@Bean 注解通常是在标有该注解的方法中定义产生这个 bean。</p>
<p>@Bean 注解比 Component 注解的自定义性更强，而且很多地方我们只能通过 @Bean 注解来注册 bean。比如当我们引用第三方库中的类需要装配到 Spring 容器时，则只能通过 @Bean 来实现。</p>
<h3 id="bean-的注入"><a href="#bean-的注入" class="headerlink" title="bean 的注入"></a>bean 的注入</h3><p>@Autowired 可以实现自动装配，对象无需自己查找或创建与其关联的其他对象，由容器负责把需要相互协作的对象引用赋予各个对象。</p>
<h4 id="容器中查询对应类型的-bean"><a href="#容器中查询对应类型的-bean" class="headerlink" title="容器中查询对应类型的 bean"></a>容器中查询对应类型的 bean</h4><ol>
<li><p>如果查询结果刚好为一个，就将该 bean 装配给 @Autowired 指定的数据。</p>
</li>
<li><p>如果查询的结果不止一个，那么 @Autowired 会根据名称来查找。</p>
</li>
<li><p>如果上述查找的结果为空，那么会抛出异常。解决方法：使用 required=false。</p>
</li>
</ol>
<p>@Resource、@Inject、@Qualifier 和 @Value 也可以实现同样的装配效果。</p>
<h4 id="Autowired-和-Resource-之间的区别"><a href="#Autowired-和-Resource-之间的区别" class="headerlink" title="@Autowired 和 @Resource 之间的区别"></a>@Autowired 和 @Resource 之间的区别</h4><ul>
<li><p>@Autowired 默认是按照类型装配注入的。</p>
</li>
<li><p>@Resource 默认是按照名称来装配注入的，只有当找不到与名称匹配的 bean 才会按照类型来装配注入。</p>
</li>
</ul>
<h4 id="Qualifier"><a href="#Qualifier" class="headerlink" title="@Qualifier"></a>@Qualifier</h4><p>在按照类注入的基础上再根据名称注入。给类注入时不能单独使用，需要配合 @Autowired。给方法和变量注入时可以单独使用。</p>
<h4 id="Value"><a href="#Value" class="headerlink" title="@Value"></a>@Value</h4><p>基本类型和 String 无法用 @Autowired、@Resource 和 @Qualifier 实现，需要使用 @Value。可以配合 Spring 的 EL 表达式 SpEL。</p>
<h3 id="问题的分析和解决方案"><a href="#问题的分析和解决方案" class="headerlink" title="问题的分析和解决方案"></a>问题的分析和解决方案</h3><p>了解了 static、bean 的声明和注入后，来看一下出问题的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> RedisCache redisCache;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sendSms</span><span class="params">(String[] phoneNumbers)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    redisCache.setCacheObject(key,code);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原来为了 TxsmsUtils.sendSms() 方便而将这个方法设置为 static，在方法内使用 redisCache 时需要 redisCache 也是静态的。</p>
<p>然而像上面分析的，静态变量属于类，而不属于某个实例，不会由 Spring 注入并创建对象。因此 sendSms() 这个方法中是获取不到 redisCache 对象的，因此出错。</p>
<p>解决：将 sendSms() 和 redisCache 设置为非静态，即去除 static。</p>
<p>另外，对于工具类，如果需要使用其他组件，需要将工具类也声明为 Spring bean，交给 Spring 来控制，这样才能获取到组件的实例。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>静态方法中无法进行获取到 Spring bean 的实例，看似直接明了的结论，若不是像我一样在实际开发过程中遇到过 bug，并从头到尾排查一边，真的得很难有完整的理解。</p>
<p>读万卷书，行万里路。要在懂得理论知识的前提下，积极实践，总结错误。我的这条路才刚刚开始。</p>
]]></content>
      <categories>
        <category>spring</category>
      </categories>
  </entry>
  <entry>
    <title>Mafka Castle启动报错分析</title>
    <url>/blog16/</url>
    <content><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><img src="/images/blog16/IMG_3601.JPG" width="80%"/>

<p>ClassNotFoundException 定位到jar包冲突</p>
<p>为什么是mafka castle报出问题?</p>
<h1 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h1><img src="/images/blog16/IMG_3602.JPG" width="80%"/>

<p>引入frog-sdk后，frog-sdk包含mafka-client包，造成依赖冲突<br>Castle功能</p>
<img src="/images/blog16/IMG_3603.JPG" width="80%"/>

<p>Castle定位</p>
<img src="/images/blog16/IMG_3604.JPG" width="80%"/>



]]></content>
      <categories>
        <category>backend</category>
      </categories>
  </entry>
  <entry>
    <title>generatorConfig.xml获取KMS配置失败分析</title>
    <url>/blog15/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>from 安全工单，「源码代码安全扫描器」针对仓库代码进行了扫描，检测到存在硬编码敏感信息(detect_secrets)安全漏洞。</p>
<p>密码、token等数据作为C4等级的数据，依据数据安全管理标准，这类高敏数据应当存储在kms等安全的存储区中。</p>
<p>generatorConfig.xml：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">jdbcConnection</span> <span class="attr">driverClass</span>=<span class="string">"com.mysql,jdbc.Driver"</span>	</span></span><br><span class="line"><span class="tag">                <span class="attr">connectionURL</span>=<span class="string">"jdbc:mysql://10.48.236.167:5002/interactive_qa?characterEncoding=UTF8<span class="symbol">&amp;amp;</span>socketTimeout=60000<span class="symbol">&amp;amp;</span>allowMultiQueries=true<span class="symbol">&amp;amp;</span>connectTimeout=5000"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">userId</span>=<span class="string">"rds_qa_test"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">password</span>=<span class="string">"$KMS&#123;jdbc-connection-password&#125;"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="获取失败原因分析"><a href="#获取失败原因分析" class="headerlink" title="获取失败原因分析"></a>获取失败原因分析</h1><p>按照上述generatorConfig.xml文件配置，点击Maven-&gt;服务-&gt;Plugins-&gt;mybatis-generator:generate，出现以下报错: Access denied for user ‘rds_qa_test’@’11.39.239.85’ (using password:YES)$KMS{}如何发挥作用?KMS-MDP官方文档-2.2使用说明</p>
<ul>
<li><p>properties文件中使用</p>
</li>
<li><p>Java 代码中使用</p>
</li>
<li><p>Spring XML Context文件中使用(注:非generatorConfig.xml)</p>
</li>
</ul>
<p>但是在generatorConfig.xml中，不能通过$KMS(}获取、并在mybatis-generator:generate中成功生效(同时满足这两个条件)，因为mdp未实现该功能。</p>
<h1 id="一种可行思路"><a href="#一种可行思路" class="headerlink" title="一种可行思路"></a>一种可行思路</h1><p>按照 MDP MyBatisGenerator 代码生成工具-MDP官方文档-2.1可视化工具，不需要generatorConfig.xml文件，在线下直接使用mdp-mybatis-generator,并将数据库连接信息(账号、密码等)保存在此插件的相关存储位置。但由于需要配置相关的生成类名、路径等，暂不考虑。</p>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>明文密码存在于generatorConfig.xml文件中，暂无从KMS获取配置的方案，待MDP/KMS方给出解决方案后，再进行处理。</p>
]]></content>
      <categories>
        <category>other</category>
      </categories>
  </entry>
  <entry>
    <title>商详页兜底下发原因分析</title>
    <url>/blog17/</url>
    <content><![CDATA[<h1 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h1><img src="/images/blog17/IMG_3610.JPG" width="80%"/>

<ul>
<li><p>每日中午12.20左右达到高峰</p>
</li>
<li><p>每日下午14.20左右达到低谷</p>
</li>
<li><p>每日晚上23.00左右达到当日最高峰</p>
</li>
</ul>
<h1 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h1><p>根因:档期查询为空<br>进一步观察–档期查询未排期raptor:</p>
<img src="/images/blog17/IMG_3611.JPG" width="80%"/>

<p>与商详页兜底下发raptor较为重合</p>
<table>
<thead>
<tr>
<th>时间点</th>
<th>原因</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>中午12.20</td>
<td></td>
<td></td>
</tr>
<tr>
<td>晚上23.00</td>
<td>23:00档期日期切换，接口如为查询当天档期，23:00前的排期数据可能23:00    <br/>后变为未排期。导致档期查询为空。</td>
<td></td>
</tr>
</tbody></table>
<p>档期查询未排期的几种情况:</p>
<ul>
<li><p>商品排期侧调整排期:例如排期驳回、超坑踢品</p>
</li>
<li><p>物流:19点之后截单</p>
</li>
<li><p>用户:加购时有排期，点击商详页时没排期。后续可以增加pageFrom字段埋点，分析有无其他情况。</p>
</li>
</ul>
<h1 id="打点分析"><a href="#打点分析" class="headerlink" title="打点分析"></a>打点分析</h1><p><strong>兜底页大盘配置</strong><br>Name:[“PoiSkuDetailBizEmpty”]</p>
<p>Appkey:com.sankuai.salex.aggregate.goodsrender</p>
<p>Type:[“sku_detail_monitor”]</p>
<p>指标:失败次数对应代码代码块</p>
<ul>
<li>产生checkSkuEmpty=true条件有两个:查询档期cquery为空|查询cbase为空</li>
<li>依次分析1.查询档期cquery 2.查询cbase</li>
</ul>
<p>代码分析</p>
<p>1.查询档期cquery</p>
<p>SkuDetailFacade#getPoiSkuDetail</p>
<p>2.查询cbase<br>SkuDetailFacade#doHandleProduct</p>
<p>三种cbase为空，导致返回兜底页的情况:</p>
<ul>
<li><p>调cbase接口超时–Timeout。</p>
</li>
<li><p>调cbase接口失败–Fail</p>
</li>
<li><p>查询cbase结果为空</p>
</li>
</ul>
<p>注:cbase接口返回值状态码，均为默认值code=0，无法区分接口失败具体原因</p>
<h1 id="全量打点监控"><a href="#全量打点监控" class="headerlink" title="全量打点监控"></a>全量打点监控</h1><p>1.raptor监控类型</p>
<table>
<thead>
<tr>
<th></th>
<th>type</th>
<th>name</th>
<th>说明</th>
<th>兜底页下发原因占比</th>
</tr>
</thead>
<tbody><tr>
<td>已有</td>
<td>bus_exception</td>
<td>sku_no_change_null</td>
<td>SKU有效校验未通过，或未命中一品多规</td>
<td>0%</td>
</tr>
<tr>
<td>新增</td>
<td>sku_detail_monitor</td>
<td>query.schedule.sku.empty</td>
<td>查询档期cquery结果为空<br />接口:ProductQueryService#queryScheduleSkuList</td>
<td>99.8%</td>
</tr>
<tr>
<td></td>
<td></td>
<td>query.cbase.info.empty</td>
<td>查询cbase结果为空</td>
<td>0.1%</td>
</tr>
<tr>
<td></td>
<td></td>
<td>query.cbase.info.timeout</td>
<td></td>
<td>0%</td>
</tr>
<tr>
<td></td>
<td></td>
<td>query.cbase.info.fail</td>
<td></td>
<td>0%</td>
</tr>
</tbody></table>
<p>2.0ctoCall 请求超时–占比</p>
<ul>
<li>cquery–0.08%</li>
<li>cbase–0.02%</li>
</ul>
]]></content>
      <categories>
        <category>backend</category>
      </categories>
  </entry>
  <entry>
    <title>Java 原生 Socket 实现 HTTP 通信</title>
    <url>/blog12/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们很熟悉编写服务端的一个 Controller：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyController</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    MyService myService;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 获取</span></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/get"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">getUserList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;User&gt; list = myService.findAll();</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于客户端与服务端之间基于 HTTP 的网络通信，在 Spring Boot 框架的封装下，服务端如何接受 HTTP 请求，如何解析成内存中的对象，完成业务逻辑后如何输出 HTTP 响应，我们不得而知。</p>
<p>本文将利用 Java 原生 Socket，完成发送 HTTP 请求，并解析 HTTP 响应。</p>
<h2 id="HttpUrl-类"><a href="#HttpUrl-类" class="headerlink" title="HttpUrl 类"></a>HttpUrl 类</h2><p>HTTP 协议中约定的 URL 格式为：protocol://host:port/path。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpUrl</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String protocol;</span><br><span class="line">    String host;</span><br><span class="line">    <span class="keyword">int</span> port;</span><br><span class="line">    String path;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * protocol://host:port/path</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HttpUrl</span><span class="params">(String path)</span> <span class="keyword">throws</span> MalformedURLException </span>&#123;</span><br><span class="line">        URL url = <span class="keyword">new</span> URL(path);</span><br><span class="line">        protocol = url.getProtocol();</span><br><span class="line">        host = url.getHost();</span><br><span class="line">        port = url.getPort();</span><br><span class="line">        port = port == -<span class="number">1</span> ? url.getDefaultPort() : port;</span><br><span class="line">        <span class="keyword">this</span>.path = url.getFile();</span><br><span class="line">        <span class="keyword">this</span>.path = (<span class="keyword">this</span>.path == <span class="keyword">null</span> || <span class="keyword">this</span>.path.length() == <span class="number">0</span>) ? <span class="string">"/"</span> : <span class="keyword">this</span>.path;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getProtocol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> protocol;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getHost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> host;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> port;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPath</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> path;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HttpConst</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回车和换行</span></span><br><span class="line">    <span class="keyword">int</span> CR = <span class="number">13</span>;</span><br><span class="line">    <span class="keyword">int</span> LF = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    String CRLF = <span class="string">"\r\n"</span>;</span><br><span class="line">    String GET = <span class="string">"GET "</span>;</span><br><span class="line">    String HOST = <span class="string">"Host: "</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Http-报文解析类"><a href="#Http-报文解析类" class="headerlink" title="Http 报文解析类"></a>Http 报文解析类</h2><p>是整个 Socket 网络编程的核心。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpCodec</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ByteBuffer byteBuffer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HttpCodec</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        byteBuffer = ByteBuffer.allocate(<span class="number">10</span> * <span class="number">1024</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解析响应行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">readLine</span><span class="params">(InputStream inputStream)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">byte</span> b;</span><br><span class="line">            <span class="keyword">boolean</span> EndOfLine = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// 标记</span></span><br><span class="line">            byteBuffer.clear();</span><br><span class="line">            byteBuffer.mark();</span><br><span class="line">            <span class="keyword">while</span> ((b = (<span class="keyword">byte</span>) inputStream.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                byteBuffer.put(b);</span><br><span class="line">                <span class="comment">// 读取到 /r 则记录，判断下一个字节是否为 /n</span></span><br><span class="line">                <span class="keyword">if</span> (b == HttpConst.CR) &#123;</span><br><span class="line">                    EndOfLine = <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (EndOfLine) &#123;</span><br><span class="line">                    <span class="comment">// 上一个字节是 /r，并且本次读取到 /n</span></span><br><span class="line">                    <span class="keyword">if</span> (b == HttpConst.LF) &#123;</span><br><span class="line">                        <span class="comment">// 获得目前读取的所有字节</span></span><br><span class="line">                        <span class="keyword">byte</span>[] lineBytes = <span class="keyword">new</span> <span class="keyword">byte</span>[byteBuffer.position()];</span><br><span class="line">                        <span class="comment">// 返回标记位置</span></span><br><span class="line">                        byteBuffer.reset();</span><br><span class="line">                        byteBuffer.get(lineBytes);</span><br><span class="line">                        <span class="comment">// 清空 buffer 重新标记</span></span><br><span class="line">                        byteBuffer.clear();</span><br><span class="line">                        byteBuffer.mark();</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">new</span> String(lineBytes);</span><br><span class="line">                    &#125;</span><br><span class="line">                    EndOfLine = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Response Read Line."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解析响应头</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, String&gt; <span class="title">readHeaders</span><span class="params">(InputStream inputStream)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        HashMap&lt;String, String&gt; headers = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            String line = readLine(inputStream);</span><br><span class="line">            <span class="comment">// 读取到空行，则下一行开始为响应体</span></span><br><span class="line">            <span class="keyword">if</span> (line == <span class="keyword">null</span> || line.equals(<span class="string">"\r\n"</span>)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> index = line.indexOf(<span class="string">":"</span>);</span><br><span class="line">            <span class="keyword">if</span> (index &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                String name = line.substring(<span class="number">0</span>, index);</span><br><span class="line">                <span class="comment">// ":" 移动两位，总长度减去 "\r\n"</span></span><br><span class="line">                String value = line.substring(index + <span class="number">2</span>, line.length() - <span class="number">2</span>);</span><br><span class="line">                headers.put(name, value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> headers;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解析响应体</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] readBytes(InputStream inputStream, <span class="keyword">int</span> length) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[length];</span><br><span class="line">        <span class="keyword">int</span> readNum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            readNum += inputStream.read(bytes, readNum, length - readNum);</span><br><span class="line">            <span class="comment">// 读取完毕</span></span><br><span class="line">            <span class="keyword">if</span> (readNum == length) &#123;</span><br><span class="line">                <span class="keyword">return</span> bytes;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解析分块编码形式的响应体</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">readChunked</span><span class="params">(InputStream inputStream)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">boolean</span> isEmptyData = <span class="keyword">false</span>;</span><br><span class="line">        StringBuffer buffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (len &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                String line = readLine(inputStream);</span><br><span class="line">                <span class="comment">// 减掉 "\r\n"</span></span><br><span class="line">                line = line.substring(<span class="number">0</span>, line.length() - <span class="number">2</span>);</span><br><span class="line">                <span class="comment">// Chunked 编码最后一段数据为 0 \r\n\r\n</span></span><br><span class="line">                len = Integer.valueOf(line, <span class="number">16</span>);</span><br><span class="line">                isEmptyData = len == <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 块的长度不包括 "\r\n"，所以加 2，将 "\r\n" 读走</span></span><br><span class="line">                <span class="keyword">byte</span>[] bytes = readBytes(inputStream, len + <span class="number">2</span>);</span><br><span class="line">                buffer.append(<span class="keyword">new</span> String(bytes));</span><br><span class="line">                len = -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (isEmptyData) &#123;</span><br><span class="line">                    <span class="keyword">return</span> buffer.toString();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong></p>
<ul>
<li><p>Java 原生 Socket 中 InputStream 的获取，为字节流：InputStream inputStream = socket.getInputStream(); </p>
</li>
<li><p>在解析响应行 readLine() 中，需要设置 EndOfLine 标志，用来判断是响应行的最后字节 “\r\n”。</p>
</li>
<li><p>HTTP 响应体有分块编码的方式，表现为头部字段 Transfer-Encoding: chunked，有此字段则数据通过分块传输。区别于 Content-Length 显示数据的长度，分块编码可以不预先知道发送内容的总大小。</p>
</li>
</ul>
<h2 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h2><p>请求高德地图的天气 API。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">httpTest</span><span class="params">()</span> <span class="keyword">throws</span> MalformedURLException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> HttpUrl url = <span class="keyword">new</span> HttpUrl(<span class="string">"http://restapi.amap.com/v3/weather/weatherInfo?city=南京&amp;key= "</span>);</span><br><span class="line">        System.out.println(<span class="string">"protocol："</span> + url.getProtocol());</span><br><span class="line">        System.out.println(<span class="string">"host："</span> + url.getHost());</span><br><span class="line">        System.out.println(<span class="string">"port："</span> + url.getPort());</span><br><span class="line">        System.out.println(<span class="string">"path："</span> + url.getPath());</span><br><span class="line">        <span class="comment">// 使用 StringBuffer</span></span><br><span class="line">        StringBuffer buffer = createRequestPacket(url);</span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Socket 建立连接，InetSocketAddress 包含 host + port</span></span><br><span class="line">            socket.connect(<span class="keyword">new</span> InetSocketAddress(url.getHost(), url.getPort()), <span class="number">5000</span>);</span><br><span class="line">            <span class="comment">// 获取输入输出流</span></span><br><span class="line">            <span class="keyword">final</span> OutputStream outputStream = socket.getOutputStream();</span><br><span class="line">            <span class="keyword">final</span> InputStream inputStream = socket.getInputStream();</span><br><span class="line">            <span class="comment">// 输出的后三行分别为请求行、请求头、空行、请求体</span></span><br><span class="line">            System.out.println(<span class="string">"开始发送报文... \n"</span> + buffer);</span><br><span class="line">            sendRequest(buffer, outputStream);</span><br><span class="line">            <span class="comment">// 使用 lambda 表达式</span></span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                HttpCodec httpCodec = <span class="keyword">new</span> HttpCodec();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 解析响应行</span></span><br><span class="line">                    String responseLine = httpCodec.readLine(inputStream);</span><br><span class="line">                    System.out.println(<span class="string">"响应行："</span> + responseLine);</span><br><span class="line">                    System.out.println(<span class="string">"响应头："</span>);</span><br><span class="line">                    <span class="comment">// 解析响应头</span></span><br><span class="line">                    Map&lt;String, String&gt; headers = httpCodec.readHeaders(inputStream);</span><br><span class="line">                    <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : headers.entrySet()) &#123;</span><br><span class="line">                        System.out.println(entry.getKey() + <span class="string">":"</span> + entry.getValue());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 解析 Content-Length 响应体</span></span><br><span class="line">                    <span class="keyword">if</span> (headers.containsKey(<span class="string">"Content-Length"</span>)) &#123;</span><br><span class="line">                        <span class="keyword">int</span> length = Integer.valueOf(headers.get(<span class="string">"Content-Length"</span>));</span><br><span class="line">                        <span class="keyword">byte</span>[] bytes = httpCodec.readBytes(inputStream, length);</span><br><span class="line">                        System.out.println(<span class="string">"\n响应体："</span> + <span class="keyword">new</span> String(bytes));</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 分块编码</span></span><br><span class="line">                        String response = httpCodec.readChunked(inputStream);</span><br><span class="line">                        System.out.println(<span class="string">"\n分块响应体："</span> + response);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span> * <span class="number">10</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建 Http 请求</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> StringBuffer <span class="title">createRequestPacket</span><span class="params">(HttpUrl url)</span> </span>&#123;</span><br><span class="line">        StringBuffer buffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="comment">// 请求行</span></span><br><span class="line">        buffer.append(HttpConst.GET);</span><br><span class="line">        buffer.append(url.getPath());</span><br><span class="line">        buffer.append(<span class="string">" "</span>);</span><br><span class="line">        buffer.append(<span class="string">"HTTP/1.1"</span>);</span><br><span class="line">        buffer.append(HttpConst.CRLF);</span><br><span class="line">        <span class="comment">// 请求头</span></span><br><span class="line">        buffer.append(HttpConst.HOST);</span><br><span class="line">        buffer.append(url.getHost());</span><br><span class="line">        buffer.append(HttpConst.CRLF);</span><br><span class="line">        <span class="comment">// 请求体，可以为空</span></span><br><span class="line">        buffer.append(HttpConst.CRLF);</span><br><span class="line">        <span class="keyword">return</span> buffer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送 Http 请求</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendRequest</span><span class="params">(StringBuffer buffer, OutputStream outputStream)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        outputStream.write(buffer.toString().getBytes());</span><br><span class="line">        outputStream.flush();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在发送 Http 请求 sendRequest() 中，write() 先把数据写到内存缓冲区（字符转换为字节），flush() 再把内存缓冲区的数据刷新到文件中。</p>
<h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><img src="/images/blog12/test.png" width="80%"/>



<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>用 Socket 进行网络通信，本质上是 I/O 操作，将响应报文解析成内存中的对象，我认为是核心。</p>
<p>后续我将继续研究 Spring Boot 框架内是如何处理 HTTP 请求，并转发到对应 Controller 上的。</p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="https://blog.csdn.net/CrazyMo_/article/details/88642354" target="_blank" rel="noopener">https://blog.csdn.net/CrazyMo_/article/details/88642354</a></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>Java 集合类的 contains 方法与 equals 方法的关系分析</title>
    <url>/blog13/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>我在学习 ArrayList 类主要方法时，写过一段关于 contains() 的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;Integer&gt; l1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;Integer&gt; l2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">l1.add(<span class="number">1</span>);</span><br><span class="line">l1.add(<span class="number">2</span>);</span><br><span class="line">l2.add(<span class="number">1</span>);</span><br><span class="line">l2.add(<span class="number">2</span>);</span><br><span class="line">System.out.println(l1.hashCode());</span><br><span class="line">System.out.println(l2.hashCode());</span><br><span class="line">System.out.println(l1 == l2);</span><br><span class="line">System.out.println(l1.equals(l2));</span><br><span class="line">list.add(l1);</span><br><span class="line">System.out.println(list.contains(l2));  <span class="comment">//&lt;-在这里</span></span><br></pre></td></tr></table></figure>

<p>and 输出结果为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">994</span></span><br><span class="line"><span class="number">994</span></span><br><span class="line"><span class="keyword">false</span></span><br><span class="line"><span class="keyword">true</span>  <span class="comment">//equals() 的结果</span></span><br><span class="line"><span class="keyword">true</span>  <span class="comment">//contains() 的结果</span></span><br></pre></td></tr></table></figure>

<p>注意这里判断的是 list.contains(l2)，而 list 内只添加过 l1，结果却是存在！</p>
<h2 id="contains-源码分析"><a href="#contains-源码分析" class="headerlink" title="contains() 源码分析"></a>contains() 源码分析</h2><p>在 ArrayList 类中，contains() 调用了 indexOf() 进行判断是否包含：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">  	<span class="keyword">return</span> indexOf(o) &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)</span><br><span class="line">              	<span class="keyword">return</span> i;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">              	<span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，indexOf() 中通过 equals() 比较 elementData[i]，返回一个 index。</p>
<p>elementData 在 ArrayList 类的定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">transient</span> Object[] elementData;</span><br></pre></td></tr></table></figure>

<p>逻辑简单，综合上面输出结果可以看到，equals() 和 contains() 的结果都为 true，而 == 的结果为 false。</p>
<p>复习一下 == 和 equals() 的比较。</p>
<h2 id="和-equals-的比较"><a href="#和-equals-的比较" class="headerlink" title="== 和 equals() 的比较"></a>== 和 equals() 的比较</h2><p><strong>==</strong></p>
<ul>
<li><p>基本数据类型 == 比较的是值。</p>
</li>
<li><p>引用数据类型 == 判断两个变量是否引用同一个对象。</p>
</li>
</ul>
<p><strong>equals()</strong></p>
<p>equals() 判断引用的对象是否等价。equals 方法不能作用于基本数据类型的变量。</p>
<p>类没有重写 equals() 方法，则通过 equals() 比较该类的两个对象时，等价于通过 == 比较这两个对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">  	<span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般，我们都重写 equals() 来比较两个对象的内容是否相等。</p>
<p><strong>equals() 的重写方法</strong></p>
<ol>
<li><p>检查是否为同一个对象的引用，如果是直接返回 true。</p>
</li>
<li><p>检查是否是同一个类型，如果不是，直接返回 false。</p>
</li>
<li><p>将 Object 对象进行转型。</p>
</li>
<li><p>判断每个关键域是否相等。</p>
</li>
</ol>
<h2 id="进一步分析"><a href="#进一步分析" class="headerlink" title="进一步分析"></a>进一步分析</h2><p>回到 contains() 源码中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">o.equals(elementData[i])</span><br></pre></td></tr></table></figure>

<p>o 为 Object 类，且 ArrayList 类没有重写 equals()，那么<u><strong>只在 contains() 这一步，是无法使 l1.equals(l2) 为 true 的。</strong></u></p>
<p>因此我们向上找原因所在，通过 debug 模式进入 equals() 中：</p>
<img src="/images/blog13/test.png" width="80%"/>

<p>然后进入了 AbstractList 类，这个类就是 ArrayList 类继承来的类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure>

<p>并且在 AbstractList 类中，我们发现重写了 equals()：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> List))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    ListIterator&lt;E&gt; e1 = listIterator();</span><br><span class="line">    ListIterator&lt;?&gt; e2 = ((List&lt;?&gt;) o).listIterator();</span><br><span class="line">    <span class="keyword">while</span> (e1.hasNext() &amp;&amp; e2.hasNext()) &#123;</span><br><span class="line">        E o1 = e1.next();</span><br><span class="line">        Object o2 = e2.next();</span><br><span class="line">        <span class="keyword">if</span> (!(o1==<span class="keyword">null</span> ? o2==<span class="keyword">null</span> : o1.equals(o2)))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> !(e1.hasNext() || e2.hasNext());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并且 AbstractList 类重写了 hashCode()：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hashCode = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (E e : <span class="keyword">this</span>)</span><br><span class="line">        hashCode = <span class="number">31</span>*hashCode + (e==<span class="keyword">null</span> ? <span class="number">0</span> : e.hashCode());</span><br><span class="line">    <span class="keyword">return</span> hashCode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>补充一个考点，为什么重写 equals() 为什么要一定要重写 hashCode()？</p>
<h2 id="为什么重写-equals-为什么要一定要重写-hashCode-？"><a href="#为什么重写-equals-为什么要一定要重写-hashCode-？" class="headerlink" title="为什么重写 equals() 为什么要一定要重写 hashCode()？"></a>为什么重写 equals() 为什么要一定要重写 hashCode()？</h2><ul>
<li>等价的两个对象哈希值一定相同，哈希值相同的两个对象不一定等价。因为计算哈希值具有随机性，两个值不同的对象可能计算出相同的哈希值。</li>
<li>如果没有重写 hashCode()，两个对象 hashCode() 得出来的值不同，等价对象无法 equals()。</li>
<li>因此为了能 equals()，必须重写 hashCode()，保证等价的两个对象哈希值也相等。</li>
<li>主要是针对 HashSet 和 HashMap 等集合类，如果没有重写 hashCode()，则会导致集合中有两个等价的对象。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>梳理一下 contains() 与 equals() 的关系：</p>
<ol>
<li>ArrayList 类继承了 AbstractList 类对 equals() 和 hashCode() 的重写，使 l1.equals(l2) 的结果为 true，因为比较的是两个 list 内存的元素的值。</li>
<li>ArrayList 类的 contains() 调用了 indexOf()，indexOf() 使用 equals() 进行元素的比较，因此 list.contains(l2) 的结果也为 true。</li>
</ol>
]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>服务治理平台 OCTO2.0-学习笔记</title>
    <url>/blog19/</url>
    <content><![CDATA[<p><strong>业界对标产品</strong></p>
<p>字节跳动CloudWeGo、阿里Dubbo、蚂蚁金服Sofa、华为ServiceComb、开源Spring Cloud。</p>
<p><strong>产品功能概览</strong></p>
<img src="/images/blog19/IMG_3626.JPG" width="80%"/>

<p>OCTO目前依赖KMS、Lion、Rhino、Cellar、MySQL等基础组件或服务，它本身不含鉴权、限流、配置等数据源，比如OCTO RPC SDK基于KMS实现服务鉴权、基于Rhino实现熔断限流等功能。</p>
<h1 id="RPC相关"><a href="#RPC相关" class="headerlink" title="RPC相关"></a>RPC相关</h1><h2 id="服务注册发现"><a href="#服务注册发现" class="headerlink" title="服务注册发现"></a><strong>服务注册发现</strong></h2><img src="/images/blog19/IMG_3629.JPG" width="80%"/>

<h2 id="ServiceMesh调用"><a href="#ServiceMesh调用" class="headerlink" title="ServiceMesh调用"></a>ServiceMesh调用</h2><img src="/images/blog19/IMG_3630.JPG" width="80%"/>

<h2 id="RPC调用全链路"><a href="#RPC调用全链路" class="headerlink" title="RPC调用全链路"></a>RPC调用全链路</h2><img src="/images/blog19/IMG_3631.JPG" width="80%"/>

<h1 id="OCTO1-0"><a href="#OCTO1-0" class="headerlink" title="OCTO1.0"></a>OCTO1.0</h1><p>2018年正式发布，实现服务注册发现、负载均衡、容错处理、降级熔断、灰度发布、调用数据可视化等服务治理功能。</p>
<p>OCTO 1.0和开源Dubbo/Spring Cloud体系类似。</p>
<img src="/images/blog19/IMG_3633.JPG" width="80%"/>

<ul>
<li><p>Provider将服务信息注册到Sg_agent中，由Sg_agent统一将节点信息注册到MNS注册中心中</p>
</li>
<li><p>Consumer则通过SgAgent从MNS中获取服务数据</p>
</li>
<li><p>MNS基于ZooKeeper(<strong>满足CP，存在性能瓶颈</strong>)持久化实例存储服务节点信息</p>
</li>
<li><p>Scanner用于对服务节点做健康检查</p>
</li>
<li><p>MNS-Controller作为ZK的缓存层，承担ZK的读请求和数据推送</p>
</li>
<li><p>Watt是OCTO数据指标建设的计算平台</p>
</li>
<li><p>MSGP是OCTO的服务治理平台门户，用户可以在其上查询服务状态以及修改应用规则</p>
</li>
</ul>
<p><strong>痛点</strong></p>
<ul>
<li>中间件和业务绑定在一起，制约着彼此迭代。核心的治理能力主要由通信框架承载，虽然做到了逻辑隔离，但中间件的逻辑不可避免会和业务在物理上耦合在一起。这种模式下，中间件引入Bug和新特性的发布 需要所有业务配合升级，这对业务的研发效率也会造成损害；</li>
<li>对多语言支持不够好。公司技术栈使用的语言主要是 Java，而其他语言也占20%；</li>
<li>异构治理体系技术治理分散，应用分布在多个部门，不能统一与其他节点协同。</li>
</ul>
<h1 id="Mesh架构"><a href="#Mesh架构" class="headerlink" title="Mesh架构"></a>Mesh架构</h1><img src="/images/blog19/IMG_3634.JPG" width="80%"/>

<ul>
<li>数据面Envoy，Sidecar通过对业务进程做流量拦截完成整体服务调用的注册/发现、负载均衡、服务路由等基本特性</li>
<li>控制面Istio，则由Pilot负责对Sidecar进行流量管理、规则管理等来治理流量</li>
</ul>
<img src="/images/blog19/IMG_3635.JPG" width="80%"/>

<p>对于社区 Istio 方案，要想实现超大规模应用集群落地，需要完成较多的技术改造。主要是因为 Istio 水平扩展能力相对薄弱，内部冗余操作较多，整体稳定性建设较为薄弱。</p>
<ul>
<li>控制面每个节点并不承载所有治理数据，系统整体做水平扩展，在此基础上提升每个实例的整体吞吐量和性能。</li>
<li>当出现机房断网等异常情况时，可以应对瞬时流量骤增的能力。</li>
<li>只做必要的 P2P 模式健康检查，配合集中式健康检查进行百万级节点管理。</li>
</ul>
<h1 id="Mesh化的OCTO2-0"><a href="#Mesh化的OCTO2-0" class="headerlink" title="Mesh化的OCTO2.0"></a>Mesh化的OCTO2.0</h1><img src="/images/blog19/IMG_3636.JPG" width="80%"/>

<p>OCTO 2.0控制平面摒弃了社区的Istio，完全自研。</p>
<p>数据平面基于开源Envoy改造。</p>
<p>运维系统负责数据面组件的升级、发布等运维工作</p>
<h2 id="流量劫持"><a href="#流量劫持" class="headerlink" title="流量劫持"></a>流量劫持</h2><p>OCTO 2.0并未采用Envoy原生方案-使用iptables对进出POD的流量进行劫持，主要考量了以下几个因素：</p>
<ol>
<li>iptables自身存在性能损失大、管控性差的问题</li>
<li>在美团现有的环境下，使用iptables存在以下几个问题：</li>
</ol>
<ul>
<li><p>HULK容器为富容器形态，业务进程和其他所有基础组件都处于同一容器中，这些组件使用了各种各样的端口。使用iptables容易造成误拦截；</p>
</li>
<li><p>美团现在存在物理机、虚拟机、容器等多个业务运行场景，基于iptables的流量劫持方案在适配这些场景时复杂度很高。</p>
</li>
</ul>
<p>鉴于上述问题，最终采用了<strong>Unix Domain Socket直连</strong>方式来实现业务进程和OCTO-Proxy之间的流量转发。</p>
<img src="/images/blog19/IMG_3637.JPG" width="80%"/>

<p>性能：</p>
<ul>
<li><p>Unix Domain Socket与iptables相比，不存在规则较多场景下iptables性能低下的问题；</p>
</li>
<li><p>Unix Domain Socket与TCP协议相比，也不需要经过网络协议栈，只是将应用层数据从一个进程拷贝到另一个进程，性能进一步提升。</p>
</li>
</ul>
<h2 id="无损重启"><a href="#无损重启" class="headerlink" title="无损重启"></a>无损重启</h2><p>在基础组件升级过程中(Proxy)提供持续、不间断的服务，做到业务流量无损及业务无感知。</p>
<p><strong>Envoy在长连接时的流量损耗</strong></p>
<img src="/images/blog19/IMG_3638.JPG" width="80%"/>

<ul>
<li><p>对于短连接，所有新的连接会在新的Proxy上创建，旧Proxy上已有的连接在响应到来后主动断开。旧Proxy的所有短连接逐渐断开，这就是“drain”（排空）的过程。连接排空之后，旧Proxy主动退出，新的Proxy继续工作。整个过程中的流量完全无损。</p>
</li>
<li><p>对于长连接，Client和旧Proxy维持一条长连接不断开，并持续使用该连接发送请求。旧Proxy进程最终退出时，该连接被动断开，此时可能尚有部分响应未返回，导致Client端请求超时。因此，Envoy的热重启对长连接场景的支持并不完美<strong>。</strong></p>
</li>
</ul>
]]></content>
      <categories>
        <category>backend</category>
      </categories>
  </entry>
  <entry>
    <title>SSM 整合</title>
    <url>/blog2/</url>
    <content><![CDATA[<p>我写篇博客记录上个阶段学习的 SSM 整合，加深一下自己对 Spring 这块知识的理解。</p>
<h1 id="什么是-SSM"><a href="#什么是-SSM" class="headerlink" title="什么是 SSM"></a>什么是 SSM</h1><p>SSM 是 Spring、SpringMVC、MyBatis 三者的缩写。根据三者的职能对应 SSM 的三层架构：<br>表现层 SpringMVC：接受用户参数，显示页面。<br>业务层 Spring：处理业务逻辑。<br>持久层 MyBatis：操作数据库。</p>
<p><img src="/images/blog2/SSM.png" alt="avatar"></p>
<p>从上图我们可以看到三层模型之间的依赖关系，并且 Spring 是三者的核心。</p>
<h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><h2 id="使用-MySQL-创建-account-表"><a href="#使用-MySQL-创建-account-表" class="headerlink" title="使用 MySQL 创建 account 表"></a>使用 MySQL 创建 account 表</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table account(</span><br><span class="line">    id int primary key auto_increment,</span><br><span class="line">    name varchar(20),</span><br><span class="line">    money double</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><img src="/images/blog2/structure.png" width="50%">

<h2 id="使用-Maven-导入项目所需依赖-JAR-包"><a href="#使用-Maven-导入项目所需依赖-JAR-包" class="headerlink" title="使用 Maven 导入项目所需依赖 JAR 包"></a>使用 Maven 导入项目所需依赖 JAR 包</h2><p>aspectj、spring-aop、spring-context、spring-web、spring-webmvc、spring-tx、spring-jdbc、mysql-connector-java、javax.servlet、mybatis、mybatis-spring、c3p0 和其他日志等 JAR 包。</p>
<h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><p>编写 Account 类，编写属性 id、name 和 money，这一步和上面创建的 account 表属性相对应。并设置 get/set 方法和 toString 方法。</p>
<p>编写 AccountDao 接口，实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 查询所有账户</span><br><span class="line">@Select(&quot;select * from account&quot;)</span><br><span class="line">public List&lt;Account&gt; findAll();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 插入帐户信息</span><br><span class="line">@Insert(&quot;insert into account (name,money) values (#&#123;name&#125;,#&#123;money&#125;)&quot;)</span><br><span class="line">public void saveAccount(Account account);</span><br></pre></td></tr></table></figure>

<p>接着 AccountServiceImpl 和 AccountController 就可以逐层调用这里的 find 和 save 方法。<br>编写 JSP 文件用来显示页面。</p>
<h1 id="整合部分"><a href="#整合部分" class="headerlink" title="整合部分"></a>整合部分</h1><h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><p>applicationContext.xml 是 Spring 的配置文件，也是 SSM 整合中的核心配置文件。负责依赖注入、声明式事务、AOP 和整合 MyBatis。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--开启注解的扫描，并且 Controller 不需要 Spring 去处理--&gt;</span><br><span class="line">&lt;context:component-scan base-package&#x3D;&quot;com.jieb&quot; &gt;</span><br><span class="line">    &lt;!--配置哪些注解不扫描--&gt;</span><br><span class="line">    &lt;context:exclude-filter type&#x3D;&quot;annotation&quot; expression&#x3D;&quot;org.springframework.stereotype.Controller&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;context:component-scan&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--声明式事务--&gt;</span><br><span class="line">&lt;!--事务管理器--&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;transactionManager&quot; class&#x3D;&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;dataSource&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--事务通知--&gt;</span><br><span class="line">&lt;tx:advice id&#x3D;&quot;txAdvice&quot; transaction-manager&#x3D;&quot;transactionManager&quot;&gt;</span><br><span class="line">    &lt;tx:attributes&gt;</span><br><span class="line">        &lt;tx:method name&#x3D;&quot;find*&quot; read-only&#x3D;&quot;true&quot;&#x2F;&gt;</span><br><span class="line">        &lt;tx:method name&#x3D;&quot;*&quot; isolation&#x3D;&quot;DEFAULT&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;tx:attributes&gt;</span><br><span class="line">&lt;&#x2F;tx:advice&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--AOP--&gt;</span><br><span class="line">&lt;aop:config&gt;</span><br><span class="line">    &lt;aop:advisor advice-ref&#x3D;&quot;txAdvice&quot; pointcut&#x3D;&quot;execution(* com.jieb.service.impl.*ServiceImpl.*(..))&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;aop:config&gt;</span><br></pre></td></tr></table></figure>

<h2 id="Spring-整合-MyBatis"><a href="#Spring-整合-MyBatis" class="headerlink" title="Spring 整合 MyBatis"></a>Spring 整合 MyBatis</h2><p>MyBatis 的主配置文件 configuration.xml 被整合到了 applicationContext.xml 之中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--Spring 整合 MyBatis--&gt;</span><br><span class="line">&lt;!--配置连接池--&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;dataSource&quot; class&#x3D;&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;driverClass&quot; value&#x3D;&quot;com.mysql.jdbc.Driver&quot;&#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;jdbcUrl&quot; value&#x3D;&quot;jdbc:mysql:&#x2F;&#x2F;&#x2F;ssm&quot;&#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;user&quot; value&#x3D;&quot;root&quot;&#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;root&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--配置 SqlSessionFactory 工厂--&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;sqlSessionFactory&quot; class&#x3D;&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;dataSource&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--配置 AccountDao 接口所在包--&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;mapperScanner&quot; class&#x3D;&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;basePackage&quot; value&#x3D;&quot;com.jieb.dao&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>

<h2 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h2><p>springmvc.xml 和 web.xml 是 SpringMVC 的配置文件。<br>springmvc.xml 负责开启注解扫描，配置视图解析器以及过滤静态资源。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--开启注解扫描，只扫描 Controller 注解--&gt;</span><br><span class="line">&lt;context:component-scan base-package&#x3D;&quot;com.jieb&quot;&gt;</span><br><span class="line">    &lt;context:include-filter type&#x3D;&quot;annotation&quot; expression&#x3D;&quot;org.springframework.stereotype.Controller&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;context:component-scan&gt;</span><br></pre></td></tr></table></figure>

<p>可以看到，Spring 整合 SpringMVC，需要把 Controller 类的工作独立出来，交给 SpringMVC 来做。Controller 属于表现层。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--配置的视图解析器对象--&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;internalResourceViewResolver&quot; class&#x3D;&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;prefix&quot; value&#x3D;&quot;&#x2F;WEB-INF&#x2F;pages&#x2F;&quot;&#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;suffix&quot; value&#x3D;&quot;.jsp&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--过滤静态资源--&gt;</span><br><span class="line">&lt;mvc:resources location&#x3D;&quot;&#x2F;css&#x2F;&quot; mapping&#x3D;&quot;&#x2F;css&#x2F;**&quot; &#x2F;&gt;</span><br><span class="line">&lt;mvc:resources location&#x3D;&quot;&#x2F;images&#x2F;&quot; mapping&#x3D;&quot;&#x2F;images&#x2F;**&quot; &#x2F;&gt;</span><br><span class="line">&lt;mvc:resources location&#x3D;&quot;&#x2F;js&#x2F;&quot; mapping&#x3D;&quot;&#x2F;js&#x2F;**&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure>

<p>web.xml 负责配置 Spring 的监听器，配置前端控制器和解决中文乱码的过滤器。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--配置 Spring 监听器，默认只加载 WEB-INF 目录下的 applicationContext.xml 配置文件--&gt;</span><br><span class="line">&lt;listener&gt;</span><br><span class="line">    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;&#x2F;listener-class&gt;</span><br><span class="line">&lt;&#x2F;listener&gt;</span><br><span class="line">&lt;!--设置配置文件的路径--&gt;</span><br><span class="line">&lt;context-param&gt;</span><br><span class="line">    &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;</span><br><span class="line">    &lt;param-value&gt;classpath:applicationContext.xml&lt;&#x2F;param-value&gt;</span><br><span class="line">&lt;&#x2F;context-param&gt;</span><br><span class="line">&lt;context-param&gt;</span><br><span class="line">    &lt;param-name&#x2F;&gt;</span><br><span class="line">    &lt;param-value&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;context-param&gt;</span><br></pre></td></tr></table></figure>

<p>监听器是 Spring 整合 SpringMVC 的核心，启动 Tomcat 服务器的时候加载 Spring 的配置文件 applicationContext.xml，用到监听器 ContextLoaderListener 监听 ServletContext 对象，让监听器取加载 Spring 的配置文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--配置前端控制器--&gt;</span><br><span class="line">&lt;servlet&gt;</span><br><span class="line">    &lt;servlet-name&gt;dispatcherServlet&lt;&#x2F;servlet-name&gt;</span><br><span class="line">    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;&#x2F;servlet-class&gt;</span><br><span class="line">    &lt;!--加载springmvc.xml配置文件--&gt;</span><br><span class="line">    &lt;init-param&gt;</span><br><span class="line">        &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;</span><br><span class="line">        &lt;param-value&gt;classpath:springmvc.xml&lt;&#x2F;param-value&gt;</span><br><span class="line">    &lt;&#x2F;init-param&gt;</span><br><span class="line">    &lt;!--启动服务器，创建该servlet--&gt;</span><br><span class="line">    &lt;load-on-startup&gt;1&lt;&#x2F;load-on-startup&gt;</span><br><span class="line">&lt;&#x2F;servlet&gt;</span><br><span class="line">&lt;servlet-mapping&gt;</span><br><span class="line">    &lt;servlet-name&gt;dispatcherServlet&lt;&#x2F;servlet-name&gt;</span><br><span class="line">    &lt;url-pattern&gt;&#x2F;&lt;&#x2F;url-pattern&gt;</span><br><span class="line">&lt;&#x2F;servlet-mapping&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--解决中文乱码的过滤器--&gt;</span><br><span class="line">&lt;filter&gt;</span><br><span class="line">    &lt;filter-name&gt;characterEncodingFilter&lt;&#x2F;filter-name&gt;</span><br><span class="line">    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;&#x2F;filter-class&gt;</span><br><span class="line">    &lt;init-param&gt;</span><br><span class="line">        &lt;param-name&gt;encoding&lt;&#x2F;param-name&gt;</span><br><span class="line">        &lt;param-value&gt;UTF-8&lt;&#x2F;param-value&gt;</span><br><span class="line">    &lt;&#x2F;init-param&gt;</span><br><span class="line">&lt;&#x2F;filter&gt;</span><br><span class="line">&lt;filter-mapping&gt;</span><br><span class="line">    &lt;filter-name&gt;characterEncodingFilter&lt;&#x2F;filter-name&gt;</span><br><span class="line">    &lt;url-pattern&gt;&#x2F;*&lt;&#x2F;url-pattern&gt;</span><br><span class="line">&lt;&#x2F;filter-mapping&gt;</span><br></pre></td></tr></table></figure>

<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>其实写博客就是一个向他人讲述的过程，根据费曼学习法，在向他人讲述一个知识点的过程中，查漏补缺，最终得到知识的升华。写博客确实是一件非常有价值的事。</p>
]]></content>
      <categories>
        <category>spring</category>
      </categories>
  </entry>
  <entry>
    <title>thrift</title>
    <url>/blog18/</url>
    <content><![CDATA[<h1 id="0-定义"><a href="#0-定义" class="headerlink" title="0.定义"></a>0.定义</h1><p>Thrift是一种接口描述语言和二进制通讯协议，它被用来定义和创建跨语言的服务。它被当作一个RPC框架来使用，是由Facebook为“大规模跨语言服务开发”而开发的。现在是Apache软件基金会的开源项目,</p>
<h1 id="1-RPC"><a href="#1-RPC" class="headerlink" title="1.RPC"></a>1.RPC</h1><p><strong>定义</strong></p>
<p>远程过程调用协议，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。</p>
<p><strong>目标</strong></p>
<p>让分布式或者微服务系统中不同服务之间的调用像本地调用一样简单。为此，RPC的把服务调用步骤都封装起来。</p>
<p><strong>其他</strong></p>
<p>RPC 协议假定某些传输协议的存在，如TCP/IP或UDP，为通信程序之间携带信息数据。在OSI 网络通信模型中，RPC跨域了传输层和应用层。</p>
<p>采用客户端(服务调用方)/服务器端(服务提供方)模式，都运行在自己的JVM中。客户端只需要引入要使用的接口，接口的实现和运行都在服务器端。</p>
<p>RPC 是对同步服务调用。 </p>
<p><strong>RPC方案</strong></p>
<p>RMI(JDK 自带)、Dubbo、Motan、gRPC、Hessian、Thrift. </p>
<p><strong>RPC和 HTTP</strong></p>
<p>如果需要和 HTTP 协议打交道，解析和封装 HTTP请求和响应，这类框架并不能算是RPC框架，比如Feign。 </p>
<p>RPC调用是面向服务的封装，比HTTP调用提高了服务的可用性和效率等。 </p>
<p><strong>RPC和 RESTfu</strong></p>
<p>RPC 主要指内部服务之间的调用，RESTful也可以用于内部服务之间的调用，但其主要用途还在于外部系统提供服务。</p>
<h2 id="RPC-调用过程"><a href="#RPC-调用过程" class="headerlink" title="RPC 调用过程"></a>RPC 调用过程</h2><p>最简单的RPC 框架</p>
<img src="/images/blog18/IMG_3621.JPG" width="80%"/>

<p>自己设计一个RPC框架</p>
<img src="/images/blog18/IMG_3622.JPG" width="80%"/>

<p>1.客户端 client 以本地调用方式(即以接口的方式)调用服务。</p>
<p>2.客户端存根 client stub 接收到调用后，负责将方法、参数等组装成能够进行网络传输的消息体(将消息体对象序列化为二进制)</p>
<p>3.客户端通过 sockets将消息发送到服务端。</p>
<p>4.服务端存根 server stub 收到消息后进行解码(将消息对象反序列化)。</p>
<p>5.服务端存根根据解码结果调用本地的服务。</p>
<p>6.本地服务执行并将结果返回给服务端存根。</p>
<p>7.服务端存根将返回结果打包成消息(将结果消息对象序列化)。</p>
<p>8.服务端 server 通过sockets将消息发送到客户端。</p>
<p>9.客户端存根接收到结果消息，并进行解码(将结果消息发序列化)。</p>
<p>10.客户端得到最终结果。</p>
<h1 id="2-架构模型"><a href="#2-架构模型" class="headerlink" title="2.架构模型"></a>2.架构模型</h1><p>cs架构</p>
<img src="/images/blog18/IMG_3623.JPG" width="80%"/>

<p>Thrif软件栈分层从下向上分别为:传输层、协议层、处理层和服务层。</p>
<ul>
<li><p>传输层(Transport Layer):传输层负责直接从网络中读取和写入数据，它定义了具体的网络传输协议;比如说TCP/IP传输等。</p>
</li>
<li><p>协议层(Protocol Layer):协议层定义了数据传输格式，负责网络传输数据的序列化和反序列化;比如说JSON、XML、二进制数据等。</p>
</li>
<li><p>处理层(Processor Layer):处理层是由具体的IDL(接口描述语言)生成的，封装了具体的底层网络传输和序列化方式，并委托给用户实现的Handler进行处理。</p>
</li>
<li><p>服务层(Server Layer):整合上述组件，提供具体的网络线程/I0服务模型，形成最终的服务。</p>
</li>
</ul>
<h1 id="3-Thrift支持的协议"><a href="#3-Thrift支持的协议" class="headerlink" title="3.Thrift支持的协议"></a>3.Thrift支持的协议</h1><h2 id="通讯协议"><a href="#通讯协议" class="headerlink" title="通讯协议"></a>通讯协议</h2><p>TBinaryProtocol</p>
<p>一种简单的二进制格式，简单，但没有为空间效率而优化。比文本协议处理起来更快，但更难于调试。</p>
<p>TCompactProtocol</p>
<p>更紧凑的二进制格式，处理起来通常同样高效。</p>
<p>TDebugProtocol</p>
<p>一种人类可读的文本格式，用来协助调试。</p>
<p>TDenseProtocol</p>
<p>与TCompactProtocol类似，将传输数据的元信息剥离。</p>
<p>TJSONProtocol</p>
<p>使用JSON对数据编码。</p>
<p>TSimpleJSONProtocol</p>
<p>一种只写协议，它不能被Thrift解析，因为它使用JSON时丢弃了元数据。适合用脚本语言来解析</p>
<h2 id="传输协议"><a href="#传输协议" class="headerlink" title="传输协议"></a>传输协议</h2><p>TFileTransport</p>
<p>该传输协议会写文件。</p>
<p>TFramedTransport</p>
<p>当使用一个非阻塞服务器时，要求使用这个传输协议。它按帧来发送数据，其中每一帧的开头是长度信息。</p>
<p>TMemoryTransport</p>
<p>使用存储器映射输入输出。(Java的实现使用了一个简单的ByteArrayOutputStream.) </p>
<p>TSocket</p>
<p>使用阻塞的套接字I/O来传输。</p>
<p>TZlibTransport</p>
<p>用zlib执行压缩。用于连接另一个传输协议。</p>
<h2 id="服务模型"><a href="#服务模型" class="headerlink" title="服务模型"></a>服务模型</h2><p>TNonblockingServer</p>
<p>一个多线程服务器，它使用非阻塞IO(Java的实现使用了NIO通道)。TFramedTransport必须跟这个服务器配套使用。</p>
<p>TSimpleServer</p>
<p>一个单线程服务器，它使用标准的阻塞IO。测试时很有用。</p>
<p>TThreadPoolServer</p>
<p>一个多线程服务器，它使用标准的阻塞I/O </p>
<p>THsHaServer</p>
<p>YHsHa引入了线程池去处理(需要使用TFramedTransport数据传输方式)，其模型把读写任务放到线程池去处理;Half-sync/Half-async(半同步半异步)的处理模式;Halt-sync是在处理I0时间上(sccept/read/writr io)</p>
<p>TThreadedSelectorServer</p>
<p>多线程选择器服务器端，对THsHaServer在异步IO模型上进行增强</p>
<h1 id="4-Thrift的数据类型"><a href="#4-Thrift的数据类型" class="headerlink" title="4.Thrift的数据类型"></a>4.Thrift的数据类型</h1><p>Thrit脚本可定义的数据类型包括以下几种类型:</p>
<p>1.基本类型:</p>
<ul>
<li><p>bool:布尔值</p>
</li>
<li><p>byte:8位有符号整数.</p>
</li>
<li><p>i16:16位有符号整数</p>
</li>
<li><p>i32:32位有符号整数</p>
</li>
<li><p>i64:64位有符号整数</p>
</li>
<li><p>douuble:64位浮点数</p>
</li>
<li><p>string:UTF-8编码的字符串</p>
</li>
<li><p>binary:二进制串</p>
</li>
</ul>
<p>2.结构体类型:</p>
<ul>
<li>truct: 定义的结构体对象</li>
</ul>
<p>3.容器类型:</p>
<ul>
<li>list:有序元素列表</li>
<li>set: 无序无重复元素集合</li>
<li>map:有序的key/value集合</li>
</ul>
<p>4.异常类型:</p>
<ul>
<li>exception:异常类型</li>
</ul>
<p>5.服务类型:</p>
<ul>
<li>service:具体对应服务的类</li>
</ul>
<h1 id="5-Thrift的网络服务模型"><a href="#5-Thrift的网络服务模型" class="headerlink" title="5.Thrift的网络服务模型"></a>5.Thrift的网络服务模型</h1><p>Thrift提供的网络服务模型:单线程、多线程、事件驱动。按是否阻塞划分为:阻塞服务模型、非阻塞服务模型。</p>
<ul>
<li><p>阻塞服务模型:TSimpleServer、TThreadPoolServer</p>
</li>
<li><p>非阻塞服务模型:TNonblockingServer、THsHaServer和TThreadedSelectorServer</p>
</li>
</ul>
<img src="/images/blog18/IMG_3624.JPG" width="80%"/>

<p>TServer源码分析</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">TServer</span> </span>&#123;</span><br><span class="line"><span class="number">2</span>	<span class="keyword">protected</span> TProcessorFactory processorFactory_;	</span><br><span class="line"><span class="number">3</span>	<span class="keyword">protected</span> TServerTransport serverTransport_;	</span><br><span class="line"><span class="number">4</span>	<span class="keyword">protected</span> TTransportFactory inputTransportFactory_;	</span><br><span class="line"><span class="keyword">protected</span> TTransportFactory outputTransportFactory_;</span><br><span class="line"><span class="number">6</span>	<span class="keyword">protected</span> TProtocolFactory inputProtocolFactory_;	</span><br><span class="line"><span class="keyword">protected</span> TProtocolFactory outputProtocolFactory_;</span><br><span class="line"><span class="number">8</span>	<span class="keyword">private</span> <span class="keyword">boolean</span> isServing;	</span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">TServer</span><span class="params">(TServer.AbstractServerArgs args)</span></span>&#123;</span><br><span class="line"><span class="number">11</span>	<span class="keyword">this</span>.processorFactory_= args.processorFactory;	</span><br><span class="line"><span class="number">12</span>	<span class="keyword">this</span>.serverTransport_= args.serverTransport;	</span><br><span class="line"><span class="number">13</span>	<span class="keyword">this</span>.inputTransportFactory_= args.inputTransportFactory;	</span><br><span class="line"><span class="number">14</span>	<span class="keyword">this</span>.outputTransportFactory_= args.outputTransportFactory;	</span><br><span class="line"><span class="number">15</span>	<span class="keyword">this</span>.inputProtocolFactory_= args.inputProtocolFactory;	</span><br><span class="line"><span class="number">16</span>	<span class="keyword">this</span>.outputProtocolFactory_ = args.outputProtocolFactory;	</span><br><span class="line"><span class="number">1718</span></span><br><span class="line"><span class="number">19</span>	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">serve</span><span class="params">()</span></span>;	</span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="number">21</span>	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">( )</span></span>&#123;	</span><br><span class="line"><span class="number">22</span></span><br><span class="line"><span class="number">23</span></span><br><span class="line"><span class="number">24</span>	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isServing</span><span class="params">()</span></span>&#123;	</span><br><span class="line"><span class="number">25</span>	<span class="keyword">return</span> <span class="keyword">this</span>.isServing;	</span><br><span class="line"> <span class="number">26</span>	&#125;	</span><br><span class="line"> <span class="number">27</span></span><br><span class="line"><span class="number">28</span>	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setServing</span><span class="params">(<span class="keyword">boolean</span> serving)</span></span>&#123;	</span><br><span class="line">I</span><br><span class="line"><span class="number">29</span>	<span class="keyword">this</span>.isServing =serving;	</span><br><span class="line"><span class="number">30</span>	&#125;	</span><br><span class="line"><span class="number">31</span></span><br><span class="line">  <span class="number">36</span>	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Args</span> <span class="keyword">extends</span> <span class="title">TServer</span>.<span class="title">AbstractServerArgs</span>&lt;<span class="title">TServer</span>.<span class="title">Args</span>&gt; </span>&#123;	</span><br><span class="line"><span class="number">37</span>	<span class="function"><span class="keyword">public</span> <span class="title">Args</span><span class="params">(TServerTransport transport)</span></span>&#123;	</span><br><span class="line"><span class="number">38</span>	<span class="keyword">super</span>(transport);	</span><br><span class="line">	<span class="number">39</span>	</span><br><span class="line"><span class="number">40</span></span><br><span class="line"><span class="number">41</span>&#125;</span><br></pre></td></tr></table></figure>

<h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><p>使用args的工厂进行构建:</p>
<table>
<thead>
<tr>
<th>工厂类型</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>TProcessorFactory</td>
<td>处理层工厂类</td>
</tr>
<tr>
<td>TTransportFactory</td>
<td>传输层输入工厂类</td>
</tr>
<tr>
<td>TTransportFactory</td>
<td>传输层输出工厂类</td>
</tr>
<tr>
<td>TProtocolFactory</td>
<td>协议层输入工厂类</td>
</tr>
<tr>
<td>TProtocolFactory</td>
<td>协议层输出工厂类</td>
</tr>
</tbody></table>
<h2 id="三个方法"><a href="#三个方法" class="headerlink" title="三个方法"></a>三个方法</h2><ul>
<li>serve()用于启动服务，</li>
<li>stop()用于关闭服务，</li>
<li>isServing()用于检测服务的起停状态。</li>
</ul>
<p>注意</p>
<p>TServer的不同实现类的启动方式不一样，因此serve()定义为抽象方法。而不是所有的服务都需要优雅的退出,因此stop()方法没有被定义为抽象</p>
<h2 id="非阻塞服务模型"><a href="#非阻塞服务模型" class="headerlink" title="非阻塞服务模型"></a>非阻塞服务模型</h2><h3 id="TNonblockingServer"><a href="#TNonblockingServer" class="headerlink" title="TNonblockingServer"></a>TNonblockingServer</h3><ul>
<li>NonblockingServer模式是单线程工作，但是采用NIO的模式，借助Channel/Selector机制,采用IO事件模型来处理</li>
<li>所有的socket都被注册到selector中，在一个线程中通过seletor循环监控所有的socket,</li>
<li>每次selector循环结束时，处理所有的处于就绪状态的socket，对于有数据到来的socket进行数据读取操作，对于有数据发送的socket则进行数据发送操作，对于监听socket则产生一个新业务socket并将其注册到selector上。<ul>
<li>注意:TNonblockingServer要求底层的传输通道必须使用TFramedTransport</li>
</ul>
</li>
</ul>
<p>优缺点:</p>
<ul>
<li>相比于阻塞服务模型的效率提升主要体现在I0多路复用上，TNonblockingServer采用非阻塞IO，对accept/read/write等I0事件进行监控和处理，同时监控多个socket的状态变化。</li>
<li>TNonblockingServer模式在业务处理上还是采用单线程股序来完成。在业务处理比较复杂、耗时的时候，例如果些销口函数需要涉服数批库执行时间股长，会导数整个服务被用责住，此时该模式效也不高，因为多个圆用请求任务依然是一个提一个执行。 </li>
</ul>
<h3 id="THsHaServer"><a href="#THsHaServer" class="headerlink" title="THsHaServer"></a>THsHaServer</h3><ul>
<li>鉴于TNonblockingServer的缺点，THsHaServer继承于TNonblockingServer，引入了线程池提高了任务处理的并发能力。</li>
<li>HHaServer半同步半异步(H4l-Sync/Htal-Async)的处理模式，Hall-Aysnc用于10事件处理(AeptRoad/wite),Haf-Syno用于业务handeritrpc的同步处理上。<ul>
<li>注意:THsHServer和TNonblockingServer一样，要求底层的传输通道必须使用TFramedTransport.</li>
</ul>
</li>
</ul>
<p>优缺点:</p>
<ul>
<li>THsHaServer与TNonblockingServer模式相比，THsHaServer在完成数据读取之后，将业务处理过程交由一个线程池来完成，主线程直接返回进行下一次循环操作，效率大大提升。</li>
<li>主线程仍然需要完成所有socket的监听接收、数据读取和数据写入操作。当并发请求数较大时，且发送数据量较多时，监听socket上新连接请求不能被及时接受。 </li>
</ul>
<h3 id="TThreadedSelectorServer"><a href="#TThreadedSelectorServer" class="headerlink" title="TThreadedSelectorServer"></a>TThreadedSelectorServer</h3><p>TThreadedSeiectorServer是对THsHaServer的一种扩充，它将selector中的读写10事件(read)write)从主线程中分离出来，同时引入worker工作线程池，它也是种Half-SyncHall-Async的服务模型。 </p>
<p>TThreadedSelectorServer模式是目前Thrit提供的最高级的线程服务模型，它内部有如果几个部分构成:</p>
<ul>
<li><p>一个AcceptThread线程对象，专门用于处理监听socket上的新连接。</p>
</li>
<li><p>若干个SelectorThread对象专门用于处理业务socket的网络O读写操作，所有网络数据的读写均是有这些线程来完成。</p>
</li>
<li><p>一个负载均衡器SelectorThreadLoadBalancer对象，主要用于AcceptThread线程接收到一个新socket连接请求时，决定将这个新连接请求分配给哪个SelectorThread线程.    </p>
</li>
<li><p>一个EMecunorServic类型的工作线程池，在SolectorTnead线程中，监听到有业务ocke中有调用请求过来，则将请求数据读取之后，交结Ex0cutorServico线程地中的线程完成此次调用的具体执行、主要用于处理每个rpc请求的handle营调处理(这部分是同步的)。    </p>
</li>
</ul>
<p>工作流程如下所示:</p>
<img src="/images/blog18/IMG_3625.JPG" width="80%"/>

<p>TThreadedSelectorServer模式中有一个专门的线程AcceptThread用于处理新连接请求，因此能够及时响应大量并发连接请求;另外它将网络/O操作分散到多个SelectorThread线程中来完成，因此能够快速对网络0进行读写操作，能够很好地应对网络/O较多的情况。</p>
]]></content>
      <categories>
        <category>backend</category>
      </categories>
  </entry>
  <entry>
    <title>ArrayList add null分析</title>
    <url>/blog14/</url>
    <content><![CDATA[<h1 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h1><p>清单申诉迁移第二阶段，灰度网店中批量多条提交申诉，且并发的代码里跳过了提交审批中心&amp;存申诉任务到db&amp;es，没有写操作，所以代码内部很快走到了写上下文list(ArrayList类)这行代码，导致并发问题。</p>
<img src="/images/blog14/IMG_3551.JPG" width="80%"/>

<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><img src="/images/blog14/IMG_3552.JPG" width="80%"/>

<p><strong>ArrayList现状</strong></p>
<ul>
<li>add方法先确认容量(包含扩容)，再赋值</li>
<li>其中，执行扩容的grow方法进行旧元素的拷贝</li>
</ul>
<p><strong>add null分析</strong></p>
<ul>
<li>后执行的ThreadB扩容时，拷贝旧元素</li>
<li>而ThreadB读取size时，先执行的ThreadA已经执行完成整体add操作，添加了一个值A到11位置，并使size++，使ThreadB读取size=12</li>
<li>ThreadB在12位置添加另一个值B，但是在ThreadB中11位置为扩容后默认值null，覆盖了11位置，导致最终结果中添加了null‘</li>
</ul>
<h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><p>from JDK8<br><strong>ArrayList.add()</strong>    </p>
<p>代码块</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**	</span></span><br><span class="line"><span class="comment"> *The array buffer into which the elements of the ArrayList are stared.	</span></span><br><span class="line"><span class="comment"> *The capacity of the ArrayList is the length of this array buffer.Any	</span></span><br><span class="line"><span class="comment"> *empty ArrayList with elementData -DEFAULTCAPACITY_EMPTY_ELEMENTOATA</span></span><br><span class="line"><span class="comment"> *will be expanded to DEFAULT_CAPACITY when the first element is added.	</span></span><br><span class="line"><span class="comment"> *transient Object[] elementData; // non-private to simplify nested class access</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">10	* The size of the ArrayList (the number of elements it contains),	</span></span><br><span class="line"><span class="comment">11</span></span><br><span class="line"><span class="comment">12	*<span class="doctag">@serial</span>	</span></span><br><span class="line"><span class="comment">13	*/</span>	</span><br><span class="line"><span class="number">14</span> <span class="keyword">private</span> <span class="keyword">int</span> size:</span><br><span class="line"><span class="number">18</span>	<span class="comment">/**	</span></span><br><span class="line"><span class="comment">19	*将指定的元素追加到此列表的末尾。	</span></span><br><span class="line"><span class="comment">20  /</span></span><br><span class="line"><span class="comment">21 public boolean add(E e)&#123;</span></span><br><span class="line"><span class="comment">22	// 加元素之前,先调用ensureCapacityInternal方法	</span></span><br><span class="line"><span class="comment">23	ensureCapacityInternal(size +1); // Increments modCount!!	</span></span><br><span class="line"><span class="comment">24	/这里看到ArrayList添加元素的实质就相当于为数组赋值	</span></span><br><span class="line"><span class="comment">25	elementDatalsize++]=e;	</span></span><br><span class="line"><span class="comment">26	return true;	</span></span><br><span class="line"><span class="comment">27&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">28</span></span><br><span class="line"><span class="comment">29// 确保内部容量达到指定的最小容量。</span></span><br><span class="line"><span class="comment">private void ensureCapacityInternal(int minCapacity)&#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">​	ensureExplicitCapacity(calculateCapacity(elementData,minCapacity));</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">// 根据给定的最小容量和当前数组元素来计算所需容量。</span></span><br><span class="line"><span class="comment">private static int calculateCapacity(0bject[] elementData, int minCapacity) &#123;</span></span><br><span class="line"><span class="comment">// 如果当前数组元素为空数组(初始情况)，返回默认容量和最小容量中的较大值作为所需容量</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">​	if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span></span><br><span class="line"><span class="comment">​		return Math.max(DEFAULT_CAPACITY,minCapacity);</span></span><br><span class="line"><span class="comment">​	// 否则直接返回最小容量</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">​	 return minCapacity;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">//判断是否需要扩容</span></span><br><span class="line"><span class="comment">private void ensureExplicitCapacity(intminCapacity) &#123;</span></span><br><span class="line"><span class="comment">	modCount++;</span></span><br><span class="line"><span class="comment">	//判断当前数组容量是否足以存储minCapacity个元素 </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">​	if (minCapacity -elementData.length &gt; 0)</span></span><br><span class="line"><span class="comment">​	//调用grow方法进行扩容 </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">​	grow(minCapacity);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">53	/**	</span></span><br><span class="line"><span class="comment">54	* ArrayList扩容的核心方法。	</span></span><br><span class="line"><span class="comment">55	*/</span>	</span><br><span class="line"><span class="number">56</span>	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;	</span><br><span class="line"><span class="number">57</span>	<span class="comment">// oldCapacity为旧容量，newCapacity为新容量	</span></span><br><span class="line"><span class="number">58</span>	<span class="keyword">int</span> oldCapacity =elementData.length;	</span><br><span class="line">	<span class="comment">// 将oldCapacity 右移一位，其效果相当于oldCapacity /2,</span></span><br><span class="line">	<span class="comment">// 我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍,</span></span><br><span class="line"><span class="number">60</span></span><br><span class="line">	<span class="keyword">int</span> newCapacity = oldCapacity +(oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line"><span class="number">63</span>	<span class="comment">// 然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，	</span></span><br><span class="line"><span class="number">64</span>	<span class="keyword">if</span> (newCapacity - minCapacity &lt;<span class="number">0</span>)	</span><br><span class="line"><span class="number">65</span>		newCapacity = minCapacity;	</span><br><span class="line"><span class="number">66</span></span><br><span class="line"><span class="number">67</span>	<span class="comment">// 如果新容量大于 MAX_ARRAY_SIZE,进入(执行)、hugeCapacity()方法来比较minCapacity和MAX_ARRAY_SIZE,	</span></span><br><span class="line"><span class="number">68</span>	<span class="comment">// 如果minCapacity大于最大容量，则新容量则为Integer,MAX_VALUE’，否则，新容量大小则为MAX_ARRAY_SIZE 即为‘Integer.MAX_VALUE -8',	</span></span><br><span class="line"><span class="number">69</span>	<span class="keyword">if</span> (newCapacity -MAX_ARRAY_SIZE &gt; <span class="number">0</span>)	</span><br><span class="line"><span class="number">70</span>		newCapacity= hugeCapacity(minCapacity);	</span><br><span class="line"><span class="number">71</span></span><br><span class="line"><span class="number">72</span>	<span class="comment">// minCapacity is usually close to size, so this is a win:	</span></span><br><span class="line"><span class="number">73</span>	elementData = Arrays.copy0f(elementData, newCapacity);	</span><br><span class="line"><span class="number">74</span>&#125;</span><br></pre></td></tr></table></figure>



<h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><p><a href="https://javaguide.cn/java/collection/arraylist-source-code.html" target="_blank" rel="noopener">https://javaguide.cn/java/collection/arraylist-source-code.html</a> </p>
<p><a href="https://cloud.tencent.com/developer/article/1684989" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1684989</a></p>
<p><a href="https://blog.csdn.net/UCLoveLikeTheWind/article/details/114649507" target="_blank" rel="noopener">https://blog.csdn.net/UCLoveLikeTheWind/article/details/114649507</a></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>blog22</title>
    <url>/blog22/</url>
    <content><![CDATA[<img src="/images/blog22/IMG_3649.JPG" width="80%"/>

<h1 id="发展过程"><a href="#发展过程" class="headerlink" title="发展过程"></a>发展过程</h1><p>ChatGPT是美国<strong>OpenAI</strong>公司研发的大参数预训练生成语言模型，是一款通用的<strong>自然语言生成模型</strong>，其中GPT “生成性预先训练转换器”(generative pretrained transformer)的缩写。该模型被互联网巨大的语料库训练之后，其可以根据你输入的文字内容来生成对应的文字回答，即为常见的聊天问答模式。</p>
<p><strong>语言模型</strong>的工作方式是对语言文本进行概率建模，用来预测下一段输出内容的概率。</p>
<img src="/images/blog22/IMG_3650.jpg" width="80%"/>

<p><strong>GPT和BERT</strong></p>
<ul>
<li><p>GPT使用的是<strong>Transformer</strong>(Google Brain 2017年提出)的Decoder组件，Decoder组件在计算某个位置时只关注文章的<strong>上文</strong>信息。GPT更适合根据上文推测下文（比如对话聊天）。</p>
</li>
<li><p>BERT使用的是<strong>Transformer</strong>的Encoder组件，Encoder组件在计算某个位置时会关注文章的<strong>上下文</strong>信息。BERT更适合嵌入式表达，即填空式的任务（比如完形填空）。</p>
</li>
</ul>
<p>🦐 <strong>GPT-1发布：</strong></p>
<p>2018年6月，OpenAl 在题为《Improving Language Understanding by <strong>Generative</strong> <strong>Pre-Training</strong>》的论文中提出了第一个GPT 模型GPT-1。从这篇论文中得出的关键结论是，<strong>Transformer 架构</strong>与<strong>无监督预训练</strong>的结合产生了可喜的结果。GPT-1 以无监督预训练+<strong>有监督微调</strong>的方式，针对特定任务进行训练，实现了 “强大的自然语言理解”。</p>
<p>🦞 <strong>GPT-2发布：</strong></p>
<p>2019年2月，OpenAI发表了第二篇论文《Language Models are <strong>Unsupervised</strong> <strong>Multitask</strong> Learners》，其中介绍了由GPT-1演变的GPT-2。尽管GPT-2 大了一个数量级，但它们在其他方面非常相似。两者之间<strong>只有一个区别</strong>：GPT-2 可以完成<strong>多任务处理</strong>。OpenAI成功地证明了半监督语言模型可以在“无需特定任务训练”的情况下，在多项任务上表现出色。该模型在零样本任务转移设置中取得了显著效果。</p>
<p>🦑 <strong>GPT-3发布：</strong></p>
<p>2020年5月，OpenAI发表《Language Models are <strong>Few-Shot</strong> Learners》，演进至GPT-3，直接让<strong>预训练模型处理任务</strong>。GPT-3 比GPT-2 大100 倍，但基本原则大体一致。</p>
<p><strong>GPT、GPT-2、GPT-3</strong></p>
<img src="/images/blog22/IMG_3651.jpg" width="80%"/>

<p>在方向上，OpenAI并未追求在特定类型任务上的表现，而是不断增强模型的<strong>泛化</strong>能力。因而就对训练数据量和参数量提出来更高的要求。伴随着巨大<strong>参数量</strong>的是巨大的<strong>训练成本</strong>，GPT-3的训练费用也达到了惊人的1200万美元，</p>
<p>🦀 <strong>InstructGPT发布：</strong></p>
<p>2022 年初(1or2月)，OpenAI发表《Training language models to follow <strong>instructions</strong> with human feedback》，使用<strong>基于人类反馈的强化学习</strong> <strong>RLHF</strong>(Deepmind 2017年提出，属于Google)和<strong>指令激发 Instruction Tuning</strong>(Google Quoc V.Le 2021年提出)</p>
<p><strong>🐳ChatGPT发布：</strong></p>
<p>2022年11月30日，ChatGPT在深度融合代码和文本预训练<strong>模型</strong>Code-davinci-002的基础上，利用Instruction tuning和RLHF技术优化获得，还应该在<strong>对话数据</strong>上进行了<strong>针对性的优化</strong>。对<strong>InstructGPT的微调。</strong></p>
<p><strong>5天用户数</strong>达到<strong>1百万</strong>。仅用<strong>两个月</strong>时间，<strong>月活</strong>用户达到<strong>1亿</strong>，是<strong>史上</strong>用户<strong>增速最快</strong>的消费应用。在美团科研合作部、美团平台/NLP中心联合策划的《<a href="https://123.sankuai.com/huati/question/110398" target="_blank" rel="noopener">Top Talk第77期：聊聊ChatGPT背后的技术</a>》活动中，<strong>2000多人观看了直播</strong>。</p>
<p>ChatGPT<strong>不开源</strong>，其参数规模，技术细节都没有对外公布。</p>
<h2 id="InstructGPT"><a href="#InstructGPT" class="headerlink" title="InstructGPT"></a>InstructGPT</h2><p>ChatGPT与Open AI此前发布的InstructGPT具有非常接近的姊妹关系，两个模型的训练过程也非常接近，因此InstructGPT有较为可靠的参考价值。</p>
<p>在InstrcutGPT之前，大部分大规模语言模型的目标都是基于上一个输入<strong>片段</strong>token来推测下一个输出片段。重复把问题以及当前生成的所有内容再作为下一次的输入，生成下一个token，直到生成完整的回答。既然一句话是基于前面所有上文的一个个词生成的，同样的原理也可以把之前的对话作为下一次问题的输入，这样下一次的回答就可以包含之前对话的上下文。</p>
<h3 id="训练模型"><a href="#训练模型" class="headerlink" title="训练模型"></a>训练模型</h3><ul>
<li>Instruction Tuning(预训练) </li>
<li>训练Reward模型</li>
<li>使用强化学习算法，进一步调整模型</li>
</ul>
<img src="/images/blog22/IMG_3652.jpg" width="80%"/>

<p>InstructGPT训练框架</p>
<h3 id="Instruction-Tuning"><a href="#Instruction-Tuning" class="headerlink" title="Instruction Tuning"></a>Instruction Tuning</h3><p><strong>NLP</strong>任务的描述、输入和输出都可以转化为自然语言描述的形式，<strong>处理任务</strong>的过程都可以转化为<strong>文本补全</strong>的过程。此时可以通过任务的描述、输入和少量的任务示例转化为执行任务的问题或指令（Prompt），通过标记员（labeler）标记希望得到的结果，进行训练，让预训练模型能够直接得到正确的结果。这是在<strong>只给定任务描述</strong>而<strong>不给定任务示例</strong>的情况下生成答案的能力。</p>
<p>Instruction Tuning的实验会划分训练任务（转化后的黄色的任务及数据集）和测试任务（转化后的绿色的任务及数据集），也就是测试任务的任务描述是训练时没有见过的（不只是数据集没见过，而是这种任务的任务指令都没见过）。这一部分重要的结论是：<strong>当训练的指令达到一定规模时，大模型能够泛化处理各种没见过的指令，在测试任务中获得不错的性能提升。</strong>这是极其重要的性质，我们不可能把世界上所有的指令都人工标注喂到大模型中。</p>
<img src="/images/blog22/IMG_3653.jpg" width="80%"/>

<p> 不同于HuggingFace的T0、Google的Flan和FlanPaLM，<strong>在InstructGPT中，Instruct Tuning的过程中没有使用开源数据集转化的数据，而是完全人工标注的数据</strong>，相比于开源数据集转化的数据，这种人工标注(覆盖生成、开放式问答、封闭式问答、聊天、重写、综述、分类、抽取等任务)的指令来源为OpenAPI开放平台<strong>收集的数据和高素质标注人员的头脑风暴</strong>，<strong>更符合人们交互的指令模式</strong>。而且，在InstructGPT论文中，<strong>只需要几万的数据</strong>就可以完成Instruction Tuning的过程，模型就能够处理各种指令给出合理的答案。</p>
<h3 id="RLHF"><a href="#RLHF" class="headerlink" title="RLHF"></a>RLHF</h3><p>通过Instruction Tuning得到目标和<strong>用户的意图</strong>是不一致的，用户的意图是让语言模型能够有用并且安全地遵循用户的<strong>指令</strong>。此处的指令也就是InstrcutGPT名字的来源，也呼应了ChatGPT的最大优势，即<strong>对用户意图的理解</strong>。</p>
<p>RLHF通过利用人类的反馈和对答案的喜好基于强化学习算法继续优化模型，<strong>模型的输出能够更加符合用户期望</strong>，并且这个过程还能赋予InstrcutGPT多种智能助手应该具有的特性（公正、质疑、无害、听取意见等）。为此，通过<strong>标记员</strong>的人工标记来训练出一个<strong>反馈模型</strong>，再使用强化学习进一步优化模型。</p>
<h3 id="InstructGPT的特点"><a href="#InstructGPT的特点" class="headerlink" title="InstructGPT的特点"></a>InstructGPT的<strong>特点</strong></h3><p>在OpenAI关于InstrcutGPT的论文中，可以找到一些直观优势的量化分析，InstrcutGPT对比GPT-3模型有如下特点：</p>
<p>1️⃣71%~88%的情况下，InstrcutGPT生成的回答要比GPT-3模型的回答更加<strong>符合训练人员的喜好</strong>。</p>
<p>2️⃣在回答真实程度上更加可靠，<strong>编造</strong>的概率从GPT-3的41%下降到InstrcutGPT的21%。</p>
<p>3️⃣InstrcutGPT产生<strong>有毒回答</strong>(指语言文字中包含仇恨言论、谣言或者歧视性内容)的概率减小了25%。</p>
<h1 id="ChatGPT的商业动向"><a href="#ChatGPT的商业动向" class="headerlink" title="ChatGPT的商业动向"></a>ChatGPT的商业动向</h1><p>2023年1月末，微软继续向OpenAI投下100亿美元，并于2月2日宣布将其旗下所有产品全线整合ChatGPT；</p>
<p>2月6日，谷歌宣布将推出一款对标产品Bard；</p>
<p>2月7日，百度内部类似于ChatGPT的项目名字确定为“文心一言”；</p>
<p>2月8日，微软正式发布整合ChatGPT的新版必应搜索引擎，微软市值涨超800亿美元。</p>
<h1 id="接触ChatGPT"><a href="#接触ChatGPT" class="headerlink" title="接触ChatGPT"></a>接触ChatGPT</h1><img src="/images/blog22/IMG_3654.jpg" width="80%"/>

<img src="/images/blog22/IMG_3655.jpg" width="80%"/>

<p>国内访问链接 <a href="https://chat.forchange.cn/" target="_blank" rel="noopener">https://chat.forchange.cn/</a></p>
<h2 id="ChatGPT的特点"><a href="#ChatGPT的特点" class="headerlink" title="ChatGPT的特点"></a>ChatGPT的特点</h2><ul>
<li>🎉Decoder 结构：适合问答模式；</li>
<li>🎈通用模型：避免在早期架构和训练阶段为特定任务做调优；</li>
<li>🧨巨量数据和参数：模型知识储备丰富；</li>
<li>🧧连续对话的能力：具备强大上下文对话能力。</li>
</ul>
<h1 id="ChatGPT的优缺点"><a href="#ChatGPT的优缺点" class="headerlink" title="ChatGPT的优缺点"></a>ChatGPT的优缺点</h1><p><strong>优点</strong></p>
<ul>
<li><strong>直观的交互方式</strong>：当问题可以用几句话概括时，ChatGPT可以将问题答案直观地展示在我们面前，跟搜索引擎相比几乎就是降维打击。</li>
<li>不断<strong>修正结论</strong>：把各种约束条件都想好，发给ChatGPT，然后就能得到一个初步的答案。如果对初步的答案不满意，还可以继续修正自己的各种条件，直到得出自己比较满意的结果。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li><p>内容缺乏准确性：ChatGPT在很多基本事实上都会出现错误。</p>
</li>
<li><p>边界模糊：模型边界模糊，结果容易不可控。</p>
</li>
<li><p>有毒回答：有毒内容出现频率高。</p>
</li>
<li><p>缺乏及时性： 搜索引擎对内容的及时性要求很高。提升及时性可能的选项包括：1）重新训练（时间金钱开销巨大）；2）Fine tuning（Overfitting 过拟合，造成对原有知识的遗忘）。</p>
</li>
<li><p>信息<strong>可追溯性</strong>：一般来说，一个可靠的信息来源会比是否能够回答问题更加重要。ChatGPT经过<strong>基于人类反馈的强化学习</strong>，信息来源十分模糊。如果我们依赖ChatGPT目前的交互形式，验证信息来源就会变得更加困难。</p>
<ul>
<li>可追溯性对大规模语言或者图像模型的重要性：1.<strong>进一步优化和排序结果</strong>。2.<strong>数据剔除，版权追溯</strong>。</li>
</ul>
</li>
</ul>
<h1 id="工程应用-酒旅场景的任务示例"><a href="#工程应用-酒旅场景的任务示例" class="headerlink" title="工程应用-酒旅场景的任务示例"></a>工程应用-酒旅场景的任务示例</h1><img src="/images/blog22/IMG_3656.jpg" width="80%"/>

<h1 id="ChatGPT代替员工"><a href="#ChatGPT代替员工" class="headerlink" title="ChatGPT代替员工"></a>ChatGPT代替员工</h1><img src="/images/blog22/IMG_3657.jpg" width="80%"/>

<p>哪些行业可能会有较大改变/颠覆(我认为)？</p>
<ul>
<li>秘书、客服</li>
<li>教育</li>
<li>文史</li>
</ul>
]]></content>
      <categories>
        <category>backend</category>
      </categories>
  </entry>
  <entry>
    <title>blog23</title>
    <url>/blog23/</url>
    <content><![CDATA[<img src="/images/blog14/IMG_3552.JPG" width="80%"/>

]]></content>
      <categories>
        <category>backend</category>
      </categories>
  </entry>
  <entry>
    <title>Selenium IDE 的简单使用</title>
    <url>/blog3/</url>
    <content><![CDATA[<p>研一上的软件测试课接到的任务，要求上去给大伙儿演示使用 Selenium 做自动测试，实现录制和重放 Selenium 脚本，并在命令行运行脚本。由于没有任何文档，只能硬着头皮面向 Google 学习，力求能做出个玩样儿交差。</p>
<p>首先了解下 Selenium：</p>
<img src="/images/blog3/屏幕快照 2019-12-25 22.59.02.png" />

<p>这是官网给的定义，大致是说 Selenium 主要是用来构建网站上的自动测试。</p>
<p>我这次的任务主要使用 Selenium IDE 这个插件来做的，特点是录制和重放特别得傻瓜式。</p>
<img src="/images/blog3/屏幕快照 2019-12-25 23.02.10.png" width="50%" />

<p>输入一个 URL，点击按钮</p>
<p><img src="/images/blog3/a.png" alt="avatar"></p>
<p>Selenium IDE 就会把你在之后对网站各种元素的操作记录下来，录制形成多条命令：</p>
<img src="/images/blog3/屏幕快照 2019-12-25 23.05.57.png" width="35%" />

<p>然后点击按钮</p>
<img src="/images/blog3/屏幕快照 2019-12-25 23.06.11.png" />

<p>就可以重放了。由于是软件测试课，需要加 assert 进行判断结果对错。</p>
<p>这里注意 assert 和 verify 两个判断：assert 遇到判断为错，会结束整个测试；而 verify 会继续后面的测试命令。</p>
<p>到这里会发现 Selenium IDE 是真的简单，但是我想说我被坑了，坑在用命令行重放录制的 .py 脚本。这里其实大部分是我是个 Unix 命令行小白，对文件系统不是很熟悉，想要找一个文件在哪还要 Google 基本的 which 命令。但是还有一部分是官方文档有一处坑。</p>
<p>Selenium IDE 的 Help 可以直接进到官方文档：</p>
<img src="/images/blog3/屏幕快照 2019-12-25 23.13.37.png" width="50%" />

<p>对，就是这个 Command-line Runner。前置装 node，selenium-side-runner 和 chromedriver，我安装文档给的 npm 装一直报错（一部分是因为图书馆网太差），一部分是版本问题。最后装完了运行 selenium-side-runner /path/to/your-project.side 时，报了 no test 的错误。为什么呢？还好有 Code Export，把前面录制的脚本到处为 .py 文件，发现：</p>
<img src="/images/blog3/屏幕快照 2019-12-25 23.18.22.png" width="75%" />

<p>这个导出的文件没有 main 函数！因此又回到官方文档，仔细思索端倪：</p>
<img src="/images/blog3/屏幕快照 2019-12-25 23.19.38.png" width="50%" />

<p>原来得用 pytest 运行这个脚本，按照文档一路搞下来的我上当了，真有你的 selenium-side-runner！然鹅待我装了前置后，运行  pytest /path/to/your-project.py 后，又报错了，这次是 no element 的错误。Google 一番，发现是浏览器打开 URL 太慢，而脚本先执行了 driver.find_element() 这一步。解决办法是用 WebDriverWait(self.driver, 20).until(EC.element_to_be_clickable()).click()，等 URL 打开了再执行点击。这一次终于完事了！</p>
<p>经过两天的苦搞，上台演示的时候还有点小兴奋！最后老师说的一句话肯定了我：Jieb 同学演示的教会了我一些知识。不过确实，在学校教书写论文的教授的思维和如此极速发展的互联网相比，难免滞后，我也不过是官网文档和各类博客的搬运工，都是受到互联万物的网络的启发。</p>
<p>尽管做的内容很小，但是是自己不断尝错探索出来的，是一种船新的感觉，因此打算写个博客记录一下。相信这迈出的第一步，能是今后千万里长路的开端！</p>
]]></content>
      <categories>
        <category>other</category>
      </categories>
  </entry>
  <entry>
    <title>C端技术挑战</title>
    <url>/blog21/</url>
    <content><![CDATA[<h1 id="C端特殊性"><a href="#C端特殊性" class="headerlink" title="C端特殊性"></a>C端特殊性</h1><p>面向用户，巨大的并发访问量，海量的数据存储，对系统稳定性和性能的要求高。</p>
<p>因此，C端复杂系统的三类技术挑战：</p>
<ul>
<li>高并发</li>
<li>高可用</li>
<li>高性能</li>
</ul>
<h1 id="大型系统建设"><a href="#大型系统建设" class="headerlink" title="大型系统建设"></a>大型系统建设</h1><ul>
<li>octo 服务拆分、服务治理：将大型系统拆分为多个子系统，每个系统连一个数据库。</li>
<li>squirrel、cellar 两类KV型缓存：能够应对高并发读，内存存储数据保证读的性能。</li>
<li>mafka：异步削峰，增大系统同时处理任务能力，应对消息量高峰。</li>
<li>rds 分库分表、读写分离</li>
<li>数据库、中间件的集群分布、主从架构</li>
<li>es 应对高并发查询</li>
</ul>
<h1 id="稳定性建设"><a href="#稳定性建设" class="headerlink" title="稳定性建设"></a>稳定性建设</h1><p>解决可用性挑战</p>
<h2 id="整体思路"><a href="#整体思路" class="headerlink" title="整体思路"></a>整体思路</h2><img src="/images/blog21/IMG_3646.JPG" width="80%"/>

<ul>
<li><strong>统一模型，提高团队在稳定性领域的专业性：</strong>专项组带头构建稳定性全景图、解决方案、成熟度衡量的指标和方式。丰富研发同学的相关知识，形成团队积累，更好指导建设和治理工作。</li>
<li><strong>量化过程，基于模型拆解指标推进治理过程：</strong>从能力域、能力项、评估项制定评估指标（定量+定性），进行全面评估，推动系统改造，实现能力提升。</li>
<li><strong>建设工具，提高治理效率，提供运营抓手：</strong>建设Moss平台（下部分阐述），补充集团基建能力，整合或创新部分工具，为业务RD在稳定性的治理和运营的过程降本增效。</li>
<li><strong>建立机制，推进各组进度，提高重视程度：</strong>通过周期的review和汇报机制，在低成本的情况下，各组制定计划并落地实施，互相review查漏补缺。</li>
</ul>
<h2 id="稳定性模型"><a href="#稳定性模型" class="headerlink" title="稳定性模型"></a>稳定性模型</h2><h3 id="全景图"><a href="#全景图" class="headerlink" title="全景图"></a>全景图</h3><img src="/images/blog21/IMG_3647.JPG" width="80%"/>

<ul>
<li>事前：流程规范、埋点监控、线上变更管理、系统运维、稳定性平台建设</li>
<li>事中：可观测、告警、定位、排查、响应、上下游沟通、容量容错容灾手段</li>
<li>事后、COE复盘、总结、工具建设</li>
</ul>
<h3 id="评估模型"><a href="#评估模型" class="headerlink" title="评估模型"></a>评估模型</h3><p>将全景图的众多事项，按照重要程度、ROI、收益等维度进行分析，得出如下七层评估模型，进而可以按“自底向上”的优先级推进并量化过程。</p>
<img src="/images/blog21/IMG_3648JPG" width="80%"/>

<ol>
<li>【基础】「可观测性」是一切的基础，在风险预防和故障处理中起到至关重要的作用。「故障处理」要求我们在“故障不可完全避免”的事实下，降低技术问题对业务的影响。</li>
<li>【必要】大多数故障的发生都是由于变更，一方面要明确落实’六要两不要（测试、灰度）”，另一方面能够通过卡控和审批拦截风险，降低故障的发生。</li>
<li>【建设】提高系统的容量、容错、容灾的基础能力，可以有效降低发生概率和故障影响，投入相对大，但长期看可持续发展。</li>
</ol>
<h2 id="可观测指标建设"><a href="#可观测指标建设" class="headerlink" title="可观测指标建设"></a>可观测指标建设</h2><table>
<thead>
<tr>
<th>维度</th>
<th>观测内容</th>
<th>监控指标</th>
<th>衡量方式</th>
<th>投入方案</th>
<th>是否完善</th>
</tr>
</thead>
<tbody><tr>
<td>业务</td>
<td>流量</td>
<td>业务量、成功率、错误码 + （下钻）</td>
<td>日/周环比、波动、阈值</td>
<td>分析-埋点-监控-告警</td>
<td><strong>有</strong></td>
</tr>
<tr>
<td>数据</td>
<td>要素下发量、率</td>
<td>日/周环比、波动、阈值</td>
<td><strong>有</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td>正确性</td>
<td>数据准确性、约束条件校验</td>
<td>波动、阈值、个例</td>
<td>回算、BCP、DQC</td>
<td><strong>-</strong></td>
<td></td>
</tr>
<tr>
<td>应用服务</td>
<td>接口</td>
<td>（URL、OctoService）QPS、TP、可用性</td>
<td>日/周环比、波动、阈值</td>
<td>实时大盘周期报告统一告警</td>
<td><strong>有</strong></td>
</tr>
<tr>
<td>下游</td>
<td>（OctoCall）QPS、TP、可用性</td>
<td>日/周环比、波动、阈值</td>
<td><strong>有</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td>异常</td>
<td>Errorlog、WarnEvent</td>
<td>error告警、event波动</td>
<td><strong>有</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td>存储</td>
<td>MysqlES</td>
<td>连接数、读写QPS/TP、慢查大表、磁盘、容灾</td>
<td>安全值风险项</td>
<td>实时告警风险工单周期巡检</td>
<td><strong>有</strong></td>
</tr>
<tr>
<td>中间件</td>
<td>mafka</td>
<td>流速、积压、负载</td>
<td>波动风险</td>
<td><strong>有</strong></td>
<td></td>
</tr>
<tr>
<td>crane</td>
<td>配置合理性、执行时间</td>
<td><strong>有</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>redis</td>
<td>大key热key、命中率、QPS/TP</td>
<td><strong>有</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>cellar</td>
<td>大key热key、命中率、QPS/TP</td>
<td><strong>有</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>容器</td>
<td>Host</td>
<td>cpu、gc、thread</td>
<td>安全值</td>
<td><strong>有</strong></td>
<td></td>
</tr>
</tbody></table>
<h1 id="高性能建设"><a href="#高性能建设" class="headerlink" title="高性能建设"></a>高性能建设</h1><p>高性能主要体现在两个方面：</p>
<ul>
<li>响应时间</li>
<li>吞吐量</li>
</ul>
<h2 id="如何提高性能"><a href="#如何提高性能" class="headerlink" title="如何提高性能"></a>如何提高性能</h2><ul>
<li><p>提高硬件能力、增加系统服务器。</p>
</li>
<li><p>使用缓存：本地缓存 JDK 自带的 Map、Guava Cache，分布式缓存 Redis、Memcache。</p>
</li>
<li><p>消息队列：异步 + 削峰 + 解耦。</p>
</li>
<li><p>采用分布式开发：不同的服务部署在不同的机器节点上，并且一个服务也可以部署在多台机器上，然后利用 Nginx 负载均衡访问。这样就解决了单点部署的缺点，大大提高的系统并发量。</p>
</li>
<li><p>业务拆分，架构重构。</p>
</li>
<li><p>数据库分库分表：读写分离、水平分表、垂直分表。</p>
</li>
<li><p>采用集群：多台机器提供相同的服务。</p>
</li>
<li><p>CDN 加速：将一些静态资源比如图片、视频等等缓存到离用户最近的网络节点。</p>
</li>
<li><p>浏览器缓存。</p>
</li>
<li><p>使用合适的连接池：数据库连接池、线程池等等。</p>
</li>
<li><p>适当使用多线程进行开发。</p>
</li>
</ul>
<h2 id="主要解决问题"><a href="#主要解决问题" class="headerlink" title="主要解决问题"></a>主要解决问题</h2><p>慢缓存、慢服务、慢sql</p>
]]></content>
      <categories>
        <category>backend</category>
      </categories>
  </entry>
  <entry>
    <title>PuTTY 的安装与使用</title>
    <url>/blog6/</url>
    <content><![CDATA[<p>我在看博客时遇到博主使用 PuTTY 作为 SSH 连接的客户端，打算借助网上其他博客，学习一下 PuTTY 的简单使用。</p>
<h2 id="PuTTY-是什么？"><a href="#PuTTY-是什么？" class="headerlink" title="PuTTY 是什么？"></a>PuTTY 是什么？</h2><p>PuTTY 是一款集成虚拟终端、系统控制台和网络文件传输为一体的自由及开放源代码的程序。包含 PSCP、PSFTP 等多个特定功能的客户端，</p>
<h2 id="mac-下-PuTTY-的安装"><a href="#mac-下-PuTTY-的安装" class="headerlink" title="mac 下 PuTTY 的安装"></a>mac 下 PuTTY 的安装</h2><h3 id="安装-MacPorts"><a href="#安装-MacPorts" class="headerlink" title="安装 MacPorts"></a>安装 MacPorts</h3><p>MacPorts 是一个包管理工具，类似 Homebrew。之所以使用 MacPorts，是因为 MacPorts 和 PuTTY 一样，都是远古时期的老家伙。我用 MacPorts 安装 PuTTY 没有出现问题，首先在<br><a href="https://distfiles.macports.org/MacPorts/" target="_blank" rel="noopener">https://distfiles.macports.org/MacPorts/</a> 上找到自己 macOS 版本所对应的 MacPorts 版本，安装完成后在终端更新 port：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo port -v selfupdate</span><br></pre></td></tr></table></figure>

<h3 id="安装-GTK"><a href="#安装-GTK" class="headerlink" title="安装 GTK+"></a>安装 GTK+</h3><p>PuTTY 使用的 GTK+ 图形界面，现在可以使用 port 安装 GTK+：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo port install gtk2</span><br></pre></td></tr></table></figure>

<h3 id="安装-XQuartz"><a href="#安装-XQuartz" class="headerlink" title="安装 XQuartz"></a>安装 XQuartz</h3><p>XQuartz 提供绘图层支持，在 <a href="https://www.xquartz.org/" target="_blank" rel="noopener">https://www.xquartz.org/</a> 下载并安装。</p>
<h3 id="安装-PuTTY"><a href="#安装-PuTTY" class="headerlink" title="安装 PuTTY"></a>安装 PuTTY</h3><p>完成上述三个前置后，通过 port 安装 PuTTY：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo port install putty</span><br></pre></td></tr></table></figure>

<h2 id="PuTTY-的使用"><a href="#PuTTY-的使用" class="headerlink" title="PuTTY 的使用"></a>PuTTY 的使用</h2><h3 id="通过-XQuartz-打开-PuTTY"><a href="#通过-XQuartz-打开-PuTTY" class="headerlink" title="通过 XQuartz 打开 PuTTY"></a>通过 XQuartz 打开 PuTTY</h3><p>完成了 PuTTY 的安装后，首先打开 XQuartz 程序，在菜单栏的应用程序中，找到<u>终端</u>，如图：</p>
<img src="/images/blog6/截屏2020-05-06上午11.58.17.png" />

<p>打开终端后，输入 <code>putty</code> 即可打开 PuTTY 的配置界面：</p>
<img src="/images/blog6/截屏2020-05-06下午12.00.20.png" width="50%" />

<p>输入访问的 IP 地址，<code>open</code> 即可打开 PuTTY 的终端：</p>
<img src="/images/blog6/截屏2020-05-06下午12.02.15.png" />

<p>然鹅，使用 root 登录后出现了 Access denied 的错误，在<br><a href="https://superuser.com/questions/539139/putty-password-access-denied" target="_blank" rel="noopener">https://superuser.com/questions/539139/putty-password-access-denied</a> 这个解答中有很明确的解释，在 <u>/etc/ssh/sshd_config </u>中加上：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PermitRootLogin yes</span><br></pre></td></tr></table></figure>

<p>完美解决 Access denied 的问题，连接到了我访问的阿里云服务器。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>PuTTY 的安装巨费时间，使用起来也是不太方便，毕竟远古产物，现在不怎么会去使用它。mac 上自带的终端进行 ssh 连接或者阿里云的远程连接都远比 PuTTY 实际。</p>
]]></content>
      <categories>
        <category>other</category>
      </categories>
  </entry>
  <entry>
    <title>SimpleDateFormat 类使用避坑</title>
    <url>/blog7/</url>
    <content><![CDATA[<p>我在参加学校老师手下的一个项目时，负责的云存储套餐这块业务的后端开发，遇到了计算套餐开始和结束时间的问题，并使用了 SimpleDateFormat 类。SimpleDateFormat 是 Java 中使用较多的格式化日期的工具，配合 Calendar 类可以实现时间的计算。</p>
<h2 id="SimpleDateFormat-的使用"><a href="#SimpleDateFormat-的使用" class="headerlink" title="SimpleDateFormat 的使用"></a>SimpleDateFormat 的使用</h2><p>SimpleDateFormat 的构造方法传入想要的日期格式，parse() 将字符串转化为日期，format 则是将日期转化为字符：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SimpleDateFormat simpleDateFormat &#x3D; new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">Date date &#x3D; simpleDateFormat.parse(&quot;2020-05-19 15:06:13&quot;);    &#x2F;&#x2F; Tue May 19 15:06:13 CST 2020</span><br><span class="line">String time &#x3D; simpleDateFormat.format(date);    &#x2F;&#x2F; 2020-05-19 15:06:13</span><br></pre></td></tr></table></figure>

<p>注意 parse() 中当字符串和日期格式 pattern 不一样时，会抛 ParseException。ParseException 属于受检型的异常，需要在 try…catch… 代码块中捕获并进行处理 。</p>
<h2 id="配合-Calendar-完成日期的加减"><a href="#配合-Calendar-完成日期的加减" class="headerlink" title="配合 Calendar 完成日期的加减"></a>配合 Calendar 完成日期的加减</h2><p>Calendar 的 getInstance() 获取 Calendar 实例，setTime() 设置起始时间，add() 进行日期的加减。add() 中 Calendar.DAY_OF_MONTH 表示以天作为计算的单位，Calendar.DATE 也是相同的效果，方法的第二个参数 amount 取负数即可实现减法。如下计算下个月的日期：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SimpleDateFormat simpleDateFormat &#x3D; new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">Date date &#x3D; simpleDateFormat.parse(&quot;2020-05-19 15:06:13&quot;);</span><br><span class="line">Calendar calendar &#x3D; Calendar.getInstance();</span><br><span class="line">calendar.setTime(date);</span><br><span class="line">calendar.add(Calendar.DAY_OF_MONTH, 31);</span><br><span class="line">String endTime &#x3D; simpleDateFormat.format(calendar.getTime());    &#x2F;&#x2F; 2020-06-19 15:06:13</span><br></pre></td></tr></table></figure>

<h2 id="SimpleDateFormat-避坑"><a href="#SimpleDateFormat-避坑" class="headerlink" title="SimpleDateFormat 避坑"></a>SimpleDateFormat 避坑</h2><p><u>重点来惹</u>！一定要按照日期格式的标准写法，比如使用错误的日期格式 “YYYY-MM-dd” 时，format() 将会出现奇怪的日期：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SimpleDateFormat simpleDateFormat &#x3D; new SimpleDateFormat(&quot;YYYY-MM-dd&quot;);</span><br><span class="line">Date date &#x3D; simpleDateFormat.parse(&quot;2020-05-19&quot;);    &#x2F;&#x2F; Sun Dec 29 00:00:00 CST 2019</span><br></pre></td></tr></table></figure>

<p>标准表示日期的字符和其含义：</p>
<table>
<thead>
<tr>
<th align="center">字符</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">yyyy</td>
<td align="center">年</td>
</tr>
<tr>
<td align="center">MM</td>
<td align="center">月</td>
</tr>
<tr>
<td align="center">dd</td>
<td align="center">日</td>
</tr>
<tr>
<td align="center">hh</td>
<td align="center">12小时制</td>
</tr>
<tr>
<td align="center">HH</td>
<td align="center">24小时制</td>
</tr>
<tr>
<td align="center">mm</td>
<td align="center">分</td>
</tr>
<tr>
<td align="center">ss</td>
<td align="center">秒</td>
</tr>
<tr>
<td align="center">S</td>
<td align="center">毫秒</td>
</tr>
<tr>
<td align="center">E</td>
<td align="center">星期几</td>
</tr>
<tr>
<td align="center">D</td>
<td align="center">一年中的第几天</td>
</tr>
<tr>
<td align="center">F</td>
<td align="center">一月中的第几个星期(会把这个月总共过的天数除以7)</td>
</tr>
<tr>
<td align="center">w</td>
<td align="center">一年中的第几个星期</td>
</tr>
<tr>
<td align="center">W</td>
<td align="center">一月中的第几星期(会根据实际情况来算)</td>
</tr>
<tr>
<td align="center">a</td>
<td align="center">上下午标识</td>
</tr>
<tr>
<td align="center">k</td>
<td align="center">和HH差不多，表示24小时制</td>
</tr>
<tr>
<td align="center">K</td>
<td align="center">和hh差不多，表示12小时制</td>
</tr>
<tr>
<td align="center">z</td>
<td align="center">表示时区</td>
</tr>
</tbody></table>
<h2 id="SimpleDateFormat-为什么不是线程安全的？"><a href="#SimpleDateFormat-为什么不是线程安全的？" class="headerlink" title="SimpleDateFormat 为什么不是线程安全的？"></a>SimpleDateFormat 为什么不是线程安全的？</h2><p>额外拓展一个知识点，SimpleDateFormat 不是线程安全的。</p>
<h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>在 SimpleDateFormat 转换日期是通过 Calendar 对象来操作的，SimpleDateFormat 继承 DateFormat 类，DateFormat 类中维护一个 Calendar 对象，Calendar 实例被用来进行日期-时间计算，既被用于 format 方法也被用于 parse 方法。</p>
<p>在 parse 方法的最后，会调用 CalendarBuilder 的 establish 方法，入参就是 SimpleDateFormat 维护的 Calendar 实例，在 establish 方法中会调用 calendar 的 clear 方法。</p>
<p>SimpleDateFormat 维护的用于 format 和 parse 方法计算日期-时间的 calendar 被清空了，如果此时线程 A 将 calendar 清空且没有设置新值，线程 B 也进入 parse 方法用到了 SimpleDateFormat 对象中的 calendar 对象，此时就会产生线程安全问题。</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>每一个使用 SimpleDateFormat 对象进行日期-时间进行 format 和 parse 方法的时候就创建一个新的 SimpleDateFormat 对象，用完就销毁。此时就可以使用 ThreadLocal 将 SimpleDateFormat 绑定到线程上。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>SimpleDateFormat 虽小，但是有坑有拓展点，使用起来还是需要注意的。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>高性能队列 Disruptor</title>
    <url>/blog20/</url>
    <content><![CDATA[<p>Disruptor 是英国外汇交易公司 LMAX 开发的一个高性能队列，研发的初衷是解决内存队列的延迟问题（在性能测试中发现竟然与 I/O 操作处于同样的数量级）。基于Disruptor 开发的系统单线程能支撑每秒 600 万订单。</p>
<h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><ul>
<li><strong>RingBuffer（环形数组）</strong> : Disruptor 内部的 RingBuffer 是通过数组实现的。<ul>
<li>由于这个数组中的所有元素在初始化时一次性全部创建，因此这些元素的内存地址一般来说是连续的。这样做的好处是，当生产者不断往 RingBuffer 中插入新的事件对象时，这些事件对象的<strong>内存地址就能够保持连续</strong>，从而利用 CPU 缓存的局部性原理，将相邻的事件对象一起加载到缓存中，提高程序的性能。</li>
<li>这类似于 MySQL 的预读机制，将连续的几个页预读到内存里。</li>
<li>除此之外，RingBuffer 基于数组还支持批量操作（一次处理多个元素）、还可以避免频繁的内存分配和垃圾回收（RingBuffer 是一个固定大小的数组，当向数组中添加新元素时，如果数组已满，则新元素将覆盖掉最旧的元素）。</li>
</ul>
</li>
<li><strong>避免了伪共享问题</strong>：CPU 缓存内部是按照 Cache Line（缓存行）管理的，一般的 Cache Line 大小在 64 字节左右。Disruptor 为了确保目标字段独占一个 Cache Line，会在目标字段前后增加了 64 个字节的填充（前 56 个字节和后 8 个字节），这样可以避免 Cache Line 的伪共享（False Sharing）问题。</li>
<li><strong>无锁设计</strong>：Disruptor 采用无锁设计，避免了传统锁机制带来的竞争和延迟。<ul>
<li>Disruptor 的无锁实现起来比较复杂，主要是基于 CAS、内存屏障（Memory Barrier）、RingBuffer 等技术实现的。</li>
</ul>
</li>
</ul>
<h1 id="CPU高速缓存"><a href="#CPU高速缓存" class="headerlink" title="CPU高速缓存"></a>CPU高速缓存</h1><img src="/images/blog20/IMG_3639.JPG" width="80%"/>

<p>如果你用一种能被预测的方式访问内存的话，CPU 可以预测下个可能访问的值从内存先缓存到缓存中，来降低下次访问的延迟。 这就是利用 CPU 高速缓存的特性</p>
<h1 id="JVM内置加锁有界队列ArrayBlockingQueue"><a href="#JVM内置加锁有界队列ArrayBlockingQueue" class="headerlink" title="JVM内置加锁有界队列ArrayBlockingQueue"></a>JVM内置加锁有界队列ArrayBlockingQueue</h1><h2 id="JVM内置队列"><a href="#JVM内置队列" class="headerlink" title="JVM内置队列"></a><strong>JVM内置队列</strong></h2><table>
<thead>
<tr>
<th><strong>队列</strong></th>
<th><strong>有界性</strong></th>
<th><strong>锁</strong></th>
<th><strong>数据结构</strong></th>
</tr>
</thead>
<tbody><tr>
<td>ArrayBlockingQueue</td>
<td>bounded</td>
<td>加锁</td>
<td>arraylist</td>
</tr>
<tr>
<td>LinkedBlockingQueue</td>
<td>optionally-bounded</td>
<td>加锁</td>
<td>linkedlist</td>
</tr>
<tr>
<td>ConcurrentLinkedQueue</td>
<td>unbounded</td>
<td>无锁</td>
<td>linkedlist</td>
</tr>
<tr>
<td>LinkedTransferQueue</td>
<td>unbounded</td>
<td>无锁</td>
<td>linkedlist</td>
</tr>
<tr>
<td>PriorityBlockingQueue</td>
<td>unbounded</td>
<td>加锁</td>
<td>heap</td>
</tr>
<tr>
<td>DelayQueue</td>
<td>unbounded</td>
<td>加锁</td>
<td>heap</td>
</tr>
</tbody></table>
<p>通过不加锁(CAS)的方式实现的队列都是无界的，而加锁的方式可以实现有界队列。在稳定性要求特别高的系统中，为了防止生产者速度过快，导致内存溢出，只能选择有界队列。</p>
<p>同时，为了减少Java的垃圾回收对系统性能的影响，会尽量选择array/heap格式的数据结构。这样筛选下来，符合条件的队列就只有ArrayBlockingQueue。</p>
<p><strong>不加锁/CAS/加锁 的性能对比</strong></p>
<p>单线程情况下，不加锁的性能 &gt; CAS操作的性能 &gt; 加锁的性能。</p>
<p>在多线程情况下，为了保证线程安全，必须使用CAS或锁，这种情况下，CAS的性能超过锁的性能，前者大约是后者的8倍。</p>
<h2 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a><strong>ArrayBlockingQueue</strong></h2><p><strong>加ReentrantLock锁的offer操作</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public boolean offer(E e) &#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    final ReentrantLock lock &#x3D; this.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        if (count &#x3D;&#x3D; items.length)</span><br><span class="line">            return false;</span><br><span class="line">        else &#123;</span><br><span class="line">            insert(e);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>CAS例子 AtomicInteger的getAndAdd</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final int getAndAdd(int delta) &#123;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        int current &#x3D; get();</span><br><span class="line">        int next &#x3D; current + delta;</span><br><span class="line">        if (compareAndSet(current, next))</span><br><span class="line">            return current;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public final boolean compareAndSet(int expect, int update) &#123;</span><br><span class="line">    return unsafe.compareAndSwapInt(this, valueOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>管理生产者申请队列的 head，消费者申请队列的 tail，以及中间节点的存储，这些问题使得并发实现的设计非常复杂，除了在队列上使用一个粗粒度的锁之外，还难以管理。</p>
<p>对于 put 和 take 操作，使用整个队列上的粗粒度锁实现起来很简单，但对吞吐量来说是一个很大的瓶颈。</p>
<img src="/images/blog20/IMG_3640.JPG" width="80%"/>

<p><strong>伪共享问题</strong></p>
<p>使用相同的 cacheline 会产生伪共享问题。比如 ArrayBlockingQueue 有三个成员变量：</p>
<ul>
<li>takeIndex：需要被取走的元素下标；</li>
<li>putIndex：可被元素插入的位置的下标；</li>
<li>count：队列中元素的数量；</li>
</ul>
<p>这三个变量很容易放到一个缓存行中，但是之间修改没有太多的关联。所以每次修改，都会使之前缓存的数据失效，从而不能完全达到共享的效果。</p>
<p>当生产者线程 put 一个元素到 ArrayBlockingQueue 时，putIndex 会修改，从而导致消费者线程的缓存中的缓存行无效，需要从主存中重新读取。</p>
<p>一般的解决方案是，增大数组元素的间隔使得由不同线程存取的元素位于不同的缓存行上，以空间换时间。</p>
<p>在JDK1.8中，有专门的注解@Contended来避免伪共享。</p>
<h1 id="Disruptor环形数组"><a href="#Disruptor环形数组" class="headerlink" title="Disruptor环形数组"></a>Disruptor环形数组</h1><img src="/images/blog20/IMG_3641.JPG" width="80%"/>

<p>启动时，将预先分配环形缓冲区的所有内存，这些 entry 中的每一个通常不是传递的数据本身，类似对象池机制，而是它的容器。</p>
<ul>
<li>问题：ringbuffer默认size 256*1024，比较吃内存，曾有过OOM case；disruptor ringbuffer满时个别场景也会引起cpu飙高。</li>
</ul>
<h2 id="单生产者"><a href="#单生产者" class="headerlink" title="单生产者"></a><strong>单生产者</strong></h2><img src="/images/blog20/IMG_3642.JPG" width="80%"/>

<h2 id="多生产者"><a href="#多生产者" class="headerlink" title="多生产者"></a><strong>多生产者</strong></h2><p>多个生产者的情况下，会遇到“如何防止多个线程重复写同一个元素”的问题。</p>
<ul>
<li>Disruptor的解决方法：每个线程获取不同的一段数组空间进行操作。这个通过CAS很容易达到。只需要在分配元素的时候，通过CAS判断一下这段空间是否已经分配出去即可。</li>
</ul>
<p>但是会遇到一个新问题：如何防止读取的时候，读到还未写的元素。</p>
<ul>
<li>Disruptor在多个生产者的情况下，引入了一个与Ring Buffer大小相同的buffer：available Buffer。当某个位置写入成功的时候，便把availble Buffer相应的位置置位，标记为写入成功。读取的时候，会遍历available Buffer，来判断元素是否已经就绪。</li>
</ul>
<h3 id="读数据"><a href="#读数据" class="headerlink" title="读数据"></a>读数据</h3><img src="/images/blog20/IMG_3643.JPG" width="80%"/>

<ul>
<li><p>读线程读到下标为2的元素，三个线程Writer1/Writer2/Writer3正在向RingBuffer相应位置写数据，写线程被分配到的<strong>最大元素下标</strong>是11。</p>
</li>
<li><p>读线程申请读取到下标从3到11的元素，判断writer cursor&gt;=11。然后开始读取<strong>availableBuffer</strong>，从3开始，往后读取，发现下标为7的元素没有生产成功，于是WaitFor(11)返回6。</p>
</li>
<li><p>然后，消费者读取下标从3到6共计4个元素。</p>
</li>
<li><p>最后reader cursor指向6。</p>
</li>
</ul>
<h3 id="写数据"><a href="#写数据" class="headerlink" title="写数据"></a>写数据</h3><img src="/images/blog20/IMG_3644.JPG" width="80%"/>

<ul>
<li>Writer1和Writer2两个线程写入数组，都<strong>申请可写的数组空间</strong>。Writer1被分配了下标3到下表5的空间，Writer2被分配了下标6到下标9的空间。</li>
<li>Writer1写入下标3位置的元素，同时把available Buffer相应位置置位，标记已经写入成功，往后移一位，开始写下标4位置的元素。Writer2同样的方式。最终都写入完成。</li>
</ul>
<h1 id="Disruptor对CAT性能优化"><a href="#Disruptor对CAT性能优化" class="headerlink" title="Disruptor对CAT性能优化"></a>Disruptor对CAT性能优化</h1><h2 id="优化方向"><a href="#优化方向" class="headerlink" title="优化方向"></a>优化方向</h2><ul>
<li>线程模型优化：目的是降低上下文切换带来的开销；</li>
<li>内存优化：CAT 作为 APM 应用，每秒摄入的数据在几十到一百多 MB 级别，数据经过反序列化之后，还需要对内存报表做大量的更新操作，这个过程会创建特别多的临时对象，会造成频繁的 Young GC。CAT 内存中维护了当前小时的报表，每一个小时中，常驻内存随着时间推移逐渐增大，造成可用内存减少，频繁触发 Full GC。</li>
<li>JVM/OS/网络设置优化：JVM 已经发布到版本 11，新版本带来了一部分免费的性能提升， 另外 GC 的方式和参数也可以调整。 开启 OS 内存大页和调整网络参数等在理论上也能带来性能提升。</li>
</ul>
<h2 id="CAT服务端通过BlockingQueue生成报表"><a href="#CAT服务端通过BlockingQueue生成报表" class="headerlink" title="CAT服务端通过BlockingQueue生成报表"></a>CAT服务端通过BlockingQueue生成报表</h2><img src="/images/blog20/IMG_3645.JPG" width="80%"/>

<p>Netty Worker 线程生成 MessageTree 后，offer 到每个 Analyzer 专有队列（Blocking Queue）中，由 Analyzer 线程从队列中拉去后处理并生成对应的内存报表。</p>
<p>一组线程生成 MessageTree，并采用 BlockingQueue 发送到另一组线程来处理，这是典型的消息传递场景。适合使用Disruptor。</p>
]]></content>
      <categories>
        <category>backend</category>
      </categories>
  </entry>
  <entry>
    <title>Java 后端开发技术选型</title>
    <url>/blog4/</url>
    <content><![CDATA[<p>根据我的理解，简单谈下如何选择 Java 后端开发所用到的技术。</p>
<h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><p>Java 语言是这篇博客的核心，无论是写业务，还是底层框架的构成，都用到 Java 编写。</p>
<p>Java 相关的要点有：Java 基础，Java 容器，Java I/O，JVM 和 Java 并发。包括下面列举的要点，都在我整理的思维导图中：<a href="https://naotu.baidu.com/file/801377570e88e491545c2eed6cdfbd42?token=ba146c8e8cbca0be" target="_blank" rel="noopener">思维导图</a>，密码为 Pm6j。</p>
<img src="/images/blog4/java.svg" width="30%" />

<h2 id="Java-语言的发展"><a href="#Java-语言的发展" class="headerlink" title="Java 语言的发展"></a>Java 语言的发展</h2><p>Java 最初由任职于 Sun Microsystems 的 James Gosling 等人于 1990 年代初开发，最初被命名为 Oak，目标为家用电器等小型系统，应用在电视机、电话、闹钟、烤面包机等家用电器的控制和通信。由于这些智能化家电的市场需求没有预期的高，Sun 放弃了该项计划。</p>
<p>随着 1990 年代互联网的发展，Sun 看见 Oak 在互联网上应用的前景，于是改造了 Oak，于 1995 年 5 月 23 日以 Java 的名称正式发布。Java 伴随着互联网的迅猛发展而发展，逐渐成为重要的网络编程语言。次年 JDK1.0 诞生。</p>
<p>2004 年 9 月 30 日，J2SE1.5 发布，成为 Java 语言发展史上的里程碑。为了表示该版本的重要性，J2SE1.5 更名为 Java SE 5.0。</p>
<p>2006 年 Sun 在 JavaOne 公布 Java 开放源代码项目，并推出 OpenJDK 项目。Java 虚拟机、Java 编译器和 Java 类库以 GNU 通用公共许可证公开。</p>
<p>2009 年 4 月 20 日，Oracle 收购 Sun，此时是 Java 6。</p>
<p>2014 年 3 月 18 日，Oracle 发布 Java SE 8，成为现在 Java 开发的主流版本。我总结了 Java SE 8 主要的新特性：</p>
<p>1.lambda 表达式和函数式接口</p>
<p>2.Optional</p>
<p>3.Stream</p>
<p>4.新的日期和时间 API</p>
<p>5.接口的默认方法</p>
<p>6.多重注解</p>
<p>从 2017 年 9 月开始，每半年发布一个 Java SE 版本。到写这篇博客的时候，Java 来到了 Java SE 13。</p>
<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><p>操作系统和下面将谈到的计算机网络可以说是计算机专业最基础的两门课程，学好两者对于开发大有裨益。</p>
<p>os 相关的要点有：进程与线程，进程调度，进程同步，进程通信，死锁，内存管理。</p>
<p>os 主流为 Linux、Microsoft 和 macOS。对于软件开发而言，Linux 已经成为了主流，一个应用的运维离不开 Linux。由于 Linux 的开源、免费和稳定，现在 90% 以上的企业采用 Linux，服务端的市场已经被 Linux 占领。</p>
<img src="/images/blog4/linux.png" width="30%" />

<p>Linux 相关的要点有：文件，目录，磁盘，vi 和 vim，bash，正则表达式，进程管理，网络。</p>
<p>另外，除了 Linux，我在使用 Microsoft 和 macOS 两个操作系统后，明显感觉 macOS 会更加舒服，体现在高效的触控板，精美的 UI 和类 Unix 的便捷等等。</p>
<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><p>network 相关的要点有：分层协议，物理层，数据链路层，网络层，传输层，应用层。</p>
<p>网络部分还有两个重点：UNP 和 HTTP。</p>
<p>UNP 的要点包括：套接字，I/O 模型，I/O 复用。</p>
<p>HTTP 在网站开发部分可谓重中之重，现在流行的 RESTful 软件架构风格就是以 HTTP 为基础的。HTTP 的要点包括：HTTP 方法，HTTP 状态码，HTTP 请求响应报文结构，Cookie &amp; Session，缓存，HTTPS，HTTP/2，同源和跨域策略。</p>
<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><p>数据库部分包括计算机专业涉及到的数据库原理部分，以及 MySQL 和 Redis。数据库在后端方向尤为重要。</p>
<p>数据库原理的要点：SQL 语句，表相关语句，关系数据库，事务，视图等。另外在实际开发中，还需要注意 SQL 注入攻击，数据库连接池和 JDBC。</p>
<h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><p>MySQL 开源免费，而 Oracle 价格较高。作为学习的工具，建议使用 MySQL。另外，推荐使用 Navicat 作为管理 MySQL 的工具。</p>
<img src="/images/blog4/mysql.png" width="30%" />

<p>MySQL 的要点：索引，查询性能优化，存储引擎，切分，复制，并发一致性问题，隔离级别，封锁，MVCC。</p>
<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><p>Redis 主要用在缓存上，支持简单的键值对存储。缓存的主要目的是高性能和高可用，在项目的性能优化方面很有用，但吃透 Redis 还是很耗时间的。</p>
<img src="/images/blog4/redis.png" width="30%" />

<p>Redis 的要点：数据类型，使用场景，与 Memcached 的比较，数据淘汰策略，持久化，事务&amp;事件，复制，哨兵，分片，集群，缓存问题，一致性哈希，单线程模型。</p>
<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><p>Spring 系列是 Java 后端开发结合最紧密的框架，加快了应用的开发，学好用好 Spring 对于项目的开发至关重要。现在流行的 SSM 是首选，即 SpringMVC，Spring，MyBatis。关于三者的整合我写过 <a href="">SSM 整合</a>。</p>
<img src="/images/blog4/spring.png" width="30%" />

<p>Spring 的要点：AOP，IOC，MVC，bean，注解，事务，Spring Boot 相关。</p>
<p>相比国内较火的 MyBatis，Hibernate 更加重量级，功能更多且较难上手，不过也是持久层的一个选择。</p>
<p><img src="/images/blog4/mybatis.jpeg" width="30%" /> <img src="/images/blog4/hibernate.png" width="30%" /></p>
<h1 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h1><p>分布式在现在网络并发量高，流量大的形势下显得尤为重要。分布式部分涉及到：分布式锁，分布式事务，CAP 和 BASE，分布式一致性算法，分布式计算。</p>
<p>Spring Cloud 和 Dubbo 构成微服务，以服务的形式把一个项目分成多个模块。当然 Spring Cloud 现在有两个分支，一个为 Spring Cloud Alibaba 和 Dubbo，还包括 Sentinel、Nacos、RocketMQ、Seata 等，是国人开发的微服务架构。另一个则是 Spring Cloud Netflix，包括 Ribbon、Feign、Eureka（停止更新）、Hystrix 等。现在开发微服务也可以直接使用 Kubernetes。</p>
<img src="/images/blog4/dubbo.png" width="10%" />

<p>Dubbo 的要点：RPC，工作原理，通信协议和序列化协议，负载均衡策略和集群容错策略、动态代理策略，spi 思想。</p>
<p>Elasticsearch 是基于 Lucene 的搜索引擎。</p>
<img src="/images/blog4/elasticsearch.png" width="30%" />

<p>Hystrix 资源隔离、降级和熔断。</p>
<img src="/images/blog4/hystrix.png" width="30%" />

<p>Nginx 反向代理和负载均衡服务器。</p>
<img src="/images/blog4/nginx.png" width="30%" />

<p>ZooKeeper 配置和管理分布式组件。</p>
<img src="/images/blog4/zookeeper.jpeg" width="30%" />

<p>RocketMQ 和 Kafka 分布式架构的消息队列。</p>
<p><img src="/images/blog4/rocketmq.jpeg" width="20%" /> <img src="/images/blog4/kafka.png" width="20%" /></p>
<h1 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h1><p>我在开发过程中主要用到 Git 和 Maven。另外 Docker 是可以解决环境配置问题的一种虚拟化技术。</p>
<img src="/images/blog4/docker.png" width="30%" />

<p>Git 用来解决分布式版本控制问题，Maven 有依赖管理和一键构建两大功能。</p>
<img src="/images/blog4/git.png" width="30%" />

<img src="/images/blog4/maven.png" width="30%" />

]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL &amp; Redis 技术分享-下</title>
    <url>/blog9/</url>
    <content><![CDATA[<p>上一篇博客主要谈到 MySQL 的基础知识和高级特性，现在让我们看一下 Redis 部分。</p>
<h2 id="Redis-基础"><a href="#Redis-基础" class="headerlink" title="Redis 基础"></a>Redis 基础</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Redis 是速度非常快的非关系型内存键值数据库。<br>Redis 和 MySQL 不同之处在于，Redis 用的是 NoSQL。<br>主要用作缓存，缓存目的：</p>
<ul>
<li>高性能：操作缓存就是直接操作内存，所以速度相当快。</li>
<li>高并发：直接操作缓存能够承受的请求是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。并且缓存是走内存的，内存天然就支撑高并发。</li>
</ul>
<h3 id="为什么速度快？"><a href="#为什么速度快？" class="headerlink" title="为什么速度快？"></a>为什么速度快？</h3><ul>
<li>核心是基于非阻塞的 I/O 多路复用机制，用很少的线程也能快速处理大量任务。</li>
<li>完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于 HashMap，查找和增删的时间复杂度都是 O(1)。</li>
<li>采用单线程，数据全都在内存里，单线程去操作就是效率最高的。同时避免了不必要的上下文切换和竞争问题而消耗 CPU，不用去考虑多线程同步和各种锁的问题，如加锁释放锁和死锁导致的性能消耗。另外，单线程天然支持原子操作。</li>
</ul>
<p>其他原因：</p>
<ul>
<li>数据结构简单，对数据操作也简单。</li>
<li>底层模型，Redis 构建了自己的 VM 机制。</li>
<li>C 语言实现。</li>
<li>客户端与服务端通信使用 Redis 序列化协议 RESP 进行通信。</li>
</ul>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ul>
<li>STRING，可以实现常规 key-value 缓存应用和计数。</li>
<li>LIST，可以实现分页查询和消息队列。</li>
<li>SET，可以实现共同好友和去重。</li>
<li>HASH，可以实现存储对象。</li>
<li>ZSET，可以实现排行榜。ZSET增加了一个权重参数 score，使得集合中的元素能够按 score 进行有序排列。</li>
</ul>
<h4 id="Jedis-实现数据类型的基本操作"><a href="#Jedis-实现数据类型的基本操作" class="headerlink" title="Jedis 实现数据类型的基本操作"></a>Jedis 实现数据类型的基本操作</h4><p>同样演示代码在 <a href="https://github.com/Jiebupup/demo" target="_blank" rel="noopener">https://github.com/Jiebupup/demo</a> 中有，介绍了 Jedis 对应上述五个数据类型的操作。 </p>
<h3 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h3><p>Redis 是内存型数据库，为了保证数据在断电后不会丢失，需要将内存中的数据持久化到硬盘上。</p>
<h4 id="RDB-快照"><a href="#RDB-快照" class="headerlink" title="RDB 快照"></a>RDB 快照</h4><p>创建快照来获得存储在内存里面的数据在某个时间点上的副本，再存放到硬盘上。</p>
<p>实际操作过程是 fork 一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储。</p>
<p>可以将快照复制到其它服务器从而创建具有相同数据的服务器副本（就是 Redis 的主从结构），还可以将快照留在原服务器以便重启服务器的时候使用。<br>如果系统发生故障，将会丢失最后一次创建快照之后的数据。<br>如果数据量很大，保存快照的时间会很长。</p>
<h4 id="AOF-文件"><a href="#AOF-文件" class="headerlink" title="AOF 文件"></a>AOF 文件</h4><p>将写命令添加到 AOF 文件（Append Only File）的末尾。</p>
<p>设置同步选项：使用 AOF 持久化需要设置同步选项，从而确保写命令同步到磁盘文件上的时机。这是因为对文件进行写入并不会马上将内容同步到磁盘上，而是先存储到缓冲区，然后由操作系统决定什么时候同步到磁盘。</p>
<ul>
<li>always：会严重减低服务器的性能。</li>
<li>everysec：比较合适，可以保证系统崩溃时只会丢失一秒左右的数据，并且 Redis 每秒执行一次同步对服务器性能几乎没有任何影响。</li>
<li>no：并不能给服务器性能带来多大的提升，而且也会增加系统崩溃时数据丢失的数量。</li>
</ul>
<p>AOF 重写：随着服务器写请求的增多，AOF 文件会越来越大。Redis 提供了一种将 AOF 重写的特性，能够去除 AOF 文件中的冗余写命令。</p>
<h2 id="Redis-高级特性"><a href="#Redis-高级特性" class="headerlink" title="Redis 高级特性"></a>Redis 高级特性</h2><h3 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h3><p>Redis 的复制与 MySQL 主从复制类似。<br>Redis 复制水平扩容支撑读高并发，并且从 Redis 2.8 开始支持断点续传，即主从复制过程中，网络连接断掉了，那么可以接着上次复制的地方，继续复制下去。</p>
<h3 id="哨兵"><a href="#哨兵" class="headerlink" title="哨兵"></a>哨兵</h3><p>可以监听集群中的服务器，并在主服务器进入下线状态时，自动从从服务器中选举出新的主服务器。<br>用于实现 Redis 集群的高可用，本身也是作为一个哨兵集群去运行，互相协同工作。</p>
<h3 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h3><p>集群中有多个 master 节点，每个 master 又有多个 slave 节点。和哨兵共同实现了集群的高可用。</p>
<p>Gossip 协议与集中式协议不同：所有节点都持有一份元数据，不同的节点如果出现了元数据的变更，就不断将元数据发送给其它的节点，让其它节点也进行元数据的变更。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>总结一下这一次的技术分享。首先，分享的内容比较便基础，在整理出大量的知识点的同时，我也准备了几个 demo，争取让参与分享的同学巩固一下数据库这块的知识。</p>
<p>然后就是自己的表达能力需要提升提升，这也是我写这两篇博客的目的，希望自己能在总结和写作中，锻炼自己的表达能力。</p>
<p>最后还是谈谈我对 MySQL &amp; Redis 学习的看法，我总结的只是部分知识点，MySQL &amp; Redis 的理论知识点偏多，需要记忆的内容也很多。并且在个人项目或者不需要高并发的项目中，很多内容都用不上，用的最多的还是 CRUD。因此我认为熟练地 CRUD 还是很重要的，毕竟是各种项目的基础。如果要想提高自己的能力，对于高阶的知识点还是该记记该背背，更加重要的是写 demo，用代码实战过。  </p>
]]></content>
      <categories>
        <category>backend</category>
      </categories>
  </entry>
  <entry>
    <title>MyBatis 与 Hibernate 对比</title>
    <url>/blog5/</url>
    <content><![CDATA[<p>在我之前写过的 <a href="http://www.jiebcoder.top/2020/02/19/blog2/" target="_blank" rel="noopener">SSM 整合</a> 中，作为三层架构中的持久层，MyBatis 负责操作数据库。</p>
<p>同样本文和 MyBatis 进行对比的 Hibernate，也是当下十分火热的持久层选项。</p>
<h1 id="JPA"><a href="#JPA" class="headerlink" title="JPA"></a>JPA</h1><p>要讲 Hibernate，首先需要提到 JPA。JPA 即 Java 持久化 API，是一种规范，而 Hibernate 和 TopLink 都是其实现方式。</p>
<p>Spring Data JPA 是对 JPA 的封装。</p>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>标准化：任何符合 JPA 标准的框架都遵循同样的架构，提供相同的访问 API，经过少量的修改就能够在环境下运行。</p>
<p>容器级特性的支持：JPA 框架中支持大数据集、事务、并发等容器级事务。</p>
<p>查询能力：JPA 的查询语言是面向对象而非面向数据库的，它的查询语句 JPQL 查询的是实体类和实体类的属性。</p>
<p>高级特性：JPA 中能够支持面向对象的高级特性，如类之间的继承、多态和类之间的复杂关系。</p>
<h1 id="Hibernate"><a href="#Hibernate" class="headerlink" title="Hibernate"></a>Hibernate</h1><img src="/images/blog4/hibernate.png" width="30%" />

<p>Hibernate 是一个开放源代码的对象关系映射框架，它对 JDBC 进行了非常轻量级的对象封装，它将 POJO 与数据库表建立映射关系，是一个全自动的 ORM 框架，Hibernate 可以自动生成 SQL 语句，自动执行，使得 Java 程序员可以随心所欲的使用对象编程思维来操纵数据库。 </p>
<p>Hibernate 可以应用在任何使用 JDBC 的场合，既可以在 Java 的客户端程序使用，也可以在 Servlet/JSP 的 Web 应用中使用，最具革命意义的是，Hibernate 可以在应用 EJB 的 JaveEE 架构中取代 CMP，完成数据持久化的重任。</p>
<h1 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h1><img src="/images/blog4/mybatis.jpeg" width="30%" />

<p>MyBatis 是一个 Java 持久化框架，它通过 XML 描述符或注解把对象与存储过程或 SQL 语句关联起来。</p>
<p>MyBatis 是在 Apache 许可证 2.0 下分发的自由软件，是 iBATIS 3.0 的分支版本。</p>
<p>与其他的对象关系映射框架不同，MyBatis 并没有将 Java 对象与数据库表关联起来，而是将 Java 方法与 SQL 语句关联。</p>
<h2 id="对象关系映射-ORM"><a href="#对象关系映射-ORM" class="headerlink" title="对象关系映射 ORM"></a>对象关系映射 ORM</h2><p>用于实现面向对象编程语言里不同类型系统的数据之间的转换。数据库表与实体类相对应，数据库表的字段与实体类的属性相对应。减少对 SQL 语句的关注。</p>
<p>MyBatis 和 Hibernate 都是实现 ORM 思想的框架。</p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>MyBatis 中的 SQL 语句和主要业务代码分离，我们一般会把 MyBatis 中的 SQL 语句统一放在 XML 配置文件中，便于统一维护。解偶，提供 DAO 层，系统的设计更清晰，更容易单元测试。</p>
<p>本身就很小且简单，没有任何第三方依赖，易于使用。</p>
<p>MyBatis 屏蔽了原始的 JDBC 样板代码，专注于 SQL 的书写和属性与字段映射上。</p>
<p>MyBatis 最主要的特点就是可以手动编写 SQL 语句，能够支持多表关联查询。</p>
<h1 id="MyBatis-与-Hibernate-对比"><a href="#MyBatis-与-Hibernate-对比" class="headerlink" title="MyBatis 与 Hibernate 对比"></a>MyBatis 与 Hibernate 对比</h1><p>MyBatis 轻量级、上手快、插件丰富，Hibernate 重量级、功能齐全、精通较难。</p>
<p>MyBatis 的 SQL 自由度高，提供灵活的 SQL 编写方式。Hibernate 的 SQL 自由度低，不过也支持手动写 SQL。</p>
<p>MyBatis 开发效率低，需要自己维护 SQL。Hibernate 开发效率高，DAO 层开发简单，支持 JPA。</p>
<p>MyBatis 所以 SQL 都是依赖数据库编写的，需要针对特定数据库维护 SQL。Hibernate 高度解偶，封装了 JDBC，只需要在配置中指定数据库。</p>
<p>MyBatis 自身缓存机制较差，Hibernate 自身缓存机制较好，可避免脏读。</p>
<p>MyBatis 是 POJO 与 SQL 的映射，半 ORM。Hibernate 是 POJO 与数据库的映射，完全 ORM。</p>
<p>MyBatis 性能稍高，Hibernate 的封装方法性能低，Native 方法性能与 MyBatis 差不多。</p>
<p>MyBatis 适合复杂查询，集群间跨数据库事务时。Hibernate 适合单数据库，数据量小，无多表关联，数据库结构不稳定。</p>
<p>这里注明一点：国内使用 MyBatis 的比较多，而国外使用 Hibernate 比较多。</p>
]]></content>
      <categories>
        <category>backend</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL &amp; Redis 技术分享-上</title>
    <url>/blog8/</url>
    <content><![CDATA[<p>这块内容是 5.9 在项目组做的技术分享，由于是第一次做这种技术分享，组内的也有各种大佬，当时内心激动不已，必须写篇博客记录一下。</p>
<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>首先是后端技术栈介绍，这部分在 <a href="http://www.jiebcoder.top/2020/03/01/blog4/" target="_blank" rel="noopener">Java 后端开发技术选型</a> 这篇博客中比较详细的讲述过，主要是计算机网络、操作系统、Spring、分布式、Java、算法和数据库这几部分，引出主题 MySQL &amp; Redis。</p>
<h2 id="MySQL-基础"><a href="#MySQL-基础" class="headerlink" title="MySQL 基础"></a>MySQL 基础</h2><h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><p>先从 MySQL 开始，MySQL 是典型的 C/S 架构，客户端与服务器的连接简单而言就是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Start MySQL Server &amp; mysql -uroot -p</span><br></pre></td></tr></table></figure>

<p>-u 用户名，-p 密码（不建议直接写出来），-h 连接服务器进程所在域名或者 IP 地址（本机则可以忽略），各个参数的摆放顺序没有硬性规定。exit 退出。</p>
<p>然而客户端与服务器的连接到客户端收到服务器处理结果，并没有看起来的那么简单。下图是一次 SQL 查询在 MySQL 客户端与服务器的执行过程：</p>
<img src="/images/blog8/图片1.png" />

<p>可以看到，这个执行过程可以分为连接管理、解析与优化和存储引擎三块。</p>
<h3 id="连接管理"><a href="#连接管理" class="headerlink" title="连接管理"></a>连接管理</h3><p>连接管理中客户端与服务器连接本质上是一个进程间通信的过程，进程的通信方式有：</p>
<ul>
<li>TCP/IP</li>
<li>Windows 下的命名管道或共享内存</li>
<li>Unix 域套接字</li>
</ul>
<p>在客户端程序发起连接的时候，需要携带主机信息、用户名、密码，服务器程序会对客户端程序提供的这些信息进行认证，如果认证失败，服务器程序会拒绝连接。</p>
<p>每当有一个客户端进程连接到服务器进程时，服务器进程都会创建一个线程来专门处理与这个客户端的交互。当该客户端退出时会与服务器断开连接，服务器并不会立即把与该客户端交互的线程销毁掉，而是把它缓存起来，在另一个新的客户端再进行连接时，把这个缓存的线程分配给该新客户端。这就是数据库连接池，这样就起到了不频繁创建和销毁线程的效果，从而节省开销。<br>介绍几款第三方数据库连接池：Apache commons-dbcp（不活跃）、c3p0（很久没有更新）和 Druid（阿里）。</p>
<h3 id="解析与优化"><a href="#解析与优化" class="headerlink" title="解析与优化"></a>解析与优化</h3><p>完成连接的建立后，就进入服务器开始解析与优化。</p>
<h4 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h4><p>首先查询缓存，服务器先检查查询缓存，如果命中了缓存，则立刻返回存储在缓存中的结果。</p>
<p>当判断缓存是否命中时，MySQL 不会进行解析查询语句，而是直接使用 SQL 语句和客户端发送过来的其他原始信息。所以，任何字符上的不同，例如空格、注释等都会导致缓存的不命中。</p>
<p>如果查询请求中包含某些系统函数（同样的函数的两次调用会产生不一样的结果，比如函数 NOW）、用户自定义变量和函数、一些系统表，如 mysql、information_schema、performance_schema 数据库中的表，那这个请求就不会被缓存。当查询语句中有一些不确定的数据时，也则不会被缓存。</p>
<p>查询缓存系统会跟踪查询中涉及的每个表，如果这些表发生了变化，那么和这个表相关的所有缓存数据都将失效。</p>
<p>缓存同时也带来了额外的开销，从 MySQL5.7.20 开始，不推荐使用查询缓存，并在 MySQL8.0 中删除。</p>
<h4 id="语法解析"><a href="#语法解析" class="headerlink" title="语法解析"></a>语法解析</h4><p>从指定的文本中提取出我们需要的信息，本质上算是一个编译过程。</p>
<h4 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h4><p>优化的结果就是生成一个执行计划，这个执行计划表明了应该使用哪些索引进行查询，表之间的连接顺序是什么样的。我们可以使用 EXPLAIN 语句来查看某个语句的执行计划。</p>
<h3 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h3><p>MySQL 服务器把数据的存储和提取操作都封装到了一个叫存储引擎的模块里。我们知道表是由一行一行的记录组成的，但这只是一个逻辑上的概念，物理上如何表示记录，怎么从表中读取数据，怎么把数据写入具体的物理存储器上，这都是存储引擎负责的事情。它的功能就是接收上层传下来的指令，然后对表中的数据进行提取或写入操作。</p>
<p>在 MySQL server 完成了查询优化后，只需按照生成的执行计划调用底层存储引擎提供的 API，获取到数据后返回给客户端就好了。</p>
<p>进入 MySQL 客户端后可以通过：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SHOW ENGINES;</span><br></pre></td></tr></table></figure>

<p>查看 MySQL 支持的存储引擎，如下图：</p>
<img src="/images/blog8/截屏2020-05-22下午5.01.32.png" />

<p>在这些存储引擎中，比较重要的是 InnoDB 和 MyISAM。</p>
<h4 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h4><ul>
<li>MySQL 默认的事务型存储引擎（5.5 版本后），只有在需要它不支持的特性时，才考虑使用其它存储引擎。</li>
<li>实现了四个标准的隔离级别，默认级别是可重复读 REPEATABLE READ。</li>
<li>主索引是聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升</li>
<li>内部优化：从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建的自适应哈希索引、能够加速插入操作的插入缓冲区等。</li>
<li>支持真正的在线热备份，读写混合。其它存储引擎不支持在线热备份。</li>
<li>默认使用行级锁，在无索引无主键情况更新才会锁表。并发度高。</li>
<li>支持外键，MVCC，宕机恢复。</li>
</ul>
<h4 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h4><ul>
<li>设计简单，数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，则依然可以使用它。</li>
<li>支持压缩表（对于不会进行修改的表，极大减少磁盘空间占用）和空间数据索引。</li>
<li>只支持表级锁，不支持行级锁。只能对整张表加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。但在表有读取操作的同时，也可以往表中插入新的记录，这被称为并发插入。</li>
<li>崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢。</li>
<li>如果指定了延迟更新索引 DELAY_KEY_WRITE 选项，在每次修改执行完成时，不会立即将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入磁盘。这种方式可以极大的提升写入性能，但是在数据库或者主机崩溃时会造成索引损坏，需要执行修复操作。</li>
<li>MyISAM 更多强调的是性能，每次查询具有原子性，其执行速度比 InnoDB 更快，但不是绝对的。MyISAM 适合 SELECT 密集型的表。</li>
</ul>
<p>总结下 InnoDB &amp; MyISAM 的主要区别：事务，并发性 InnoDB支持行级锁，InnoDB 还支持外键和在线热备份，并且崩溃恢复优于MyISAM。MyISAM 简单，强调性能，支持压缩表和空间数据索引。</p>
<h3 id="数据库事务"><a href="#数据库事务" class="headerlink" title="数据库事务"></a>数据库事务</h3><p>定义：数据库管理系统执行过程中的一个逻辑单位，由一个有限的数据库操作序列构成。</p>
<h4 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h4><ul>
<li>原子性 Atomicity：事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。回滚日志 undo log 记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。</li>
<li>一致性 Consistency：数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对一个数据的读取结果都是相同的。</li>
<li>隔离性 Isolation：一个事务所做的修改在最终提交以前，对其它事务是不可见的。</li>
<li>持久性 Durability：一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。系统发生奔溃可以用重做日志 redo log 进行恢复，从而实现持久性。与回滚日志记录数据的逻辑修改不同，重做日志记录的是数据页的物理修改。</li>
</ul>
<h4 id="JDBC-实现数据库事务"><a href="#JDBC-实现数据库事务" class="headerlink" title="JDBC 实现数据库事务"></a>JDBC 实现数据库事务</h4><p>JDBC：Java 数据库连接，定义的一套操作所有关系型数据库的接口，不同数据库实现接口，提供 JAR 包。</p>
<p>JDBC 基本操作：</p>
<ol>
<li>注册驱动 DriverManager</li>
<li>获取连接 Connection</li>
<li>开启事务</li>
<li>定义 sql</li>
<li>获取执行 sql 对象 PreparedStatement</li>
<li>执行 sql</li>
<li>事务提交或回滚</li>
<li>释放资源</li>
</ol>
<p>演示代码在 <a href="https://github.com/Jiebupup/demo" target="_blank" rel="noopener">https://github.com/Jiebupup/demo</a> 中有，以转账操作为例，演示了 JDBC 连接等操作和数据库事务。 </p>
<h3 id="log"><a href="#log" class="headerlink" title="log"></a>log</h3><h4 id="bin-log"><a href="#bin-log" class="headerlink" title="bin log"></a>bin log</h4><p>二进制日志，用于记录所有更新且提交了数据或者已经潜在更新提交了数据的所有语句。语句以事件的形式保存，它描述数据更改。</p>
<p>binlog 的作用：</p>
<ul>
<li>恢复时能够最大可能地更新数据库，因为二进制日志包含备份后进行的所有更新。</li>
<li>在主复制服务器上记录所有将发送给从服务器的语句。在后面将介绍的主从复制中会有。</li>
</ul>
<h4 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h4><p>回滚日志，实现事务的原子性。在 InnoDB 中还用 undo log 来实现 MVCC。</p>
<p>在操作任何数据之前，首先将数据备份到 undo log。然后进行数据的修改。如果出现了错误或者用户执行了 ROLLBACK 语句，系统可以利用 undo log 中的备份将数据恢复到事务开始之前的状态。<br>除了可以保证事务的原子性，undo log 也可以用来辅助完成事务的持久化。</p>
<p>缺陷：每个事务提交前将数据和 undo log 写入磁盘，这样会导致大量的磁盘 I/O，因此性能很低。</p>
<h4 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h4><p>重做日志，记录新数据的备份。在事务提交前，只要将 redo log 持久化即可，不需要将数据持久化。</p>
<p>当系统崩溃时，虽然数据没有持久化，但是 redo log 已经持久化。系统可以根据 redo log 的内容，将所有数据恢复到最新的状态。</p>
<p>redo log 包括两部分：</p>
<ul>
<li>一是内存中的日志缓冲 buffer，该部分日志是易失性的。</li>
<li>二是磁盘上的重做日志文件 file，该部分日志是持久的。</li>
</ul>
<h3 id="并发一致性问题"><a href="#并发一致性问题" class="headerlink" title="并发一致性问题"></a>并发一致性问题</h3><ul>
<li>丢失修改：T1 和 T2 两个事务都对一个数据进行修改，T1 先修改，T2 随后修改，T2 的修改覆盖了 T1 的修改。</li>
<li>读脏数据：T1 修改一个数据，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据。</li>
<li>不可重复读：T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。</li>
<li>幻读：T1 读取某个范围（多行）的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。</li>
</ul>
<p>并发一致性问题从上到下一致性问题越来越严重。</p>
<h3 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h3><ul>
<li>未提交读 READ UNCOMMITTED：事务中的修改，即使没有提交，对其它事务也是可见的。</li>
<li>提交读 READ COMMITTED：一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。大部分数据库系统的隔离级别都是 READ COMMITTED。</li>
<li>可重复读 REPEATABLE READ：保证在同一个事务中多次读取同样数据的结果是一样的。MySQL 默认是 REPEATABLE READ。通过 MVCC + Next-Key Locks 防止幻读。</li>
<li>可串行化 SERIALIZABLE：强制事务串行执行，这样多个事务互不干扰，不会出现并发一致性问题。需要加锁实现，保证同一时间只有一个事务执行。</li>
</ul>
<p>对应隔离级别解决并发一致性问题。如图：</p>
<img src="/images/blog8/图片2.png" />

<h3 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h3><p>多版本并发控制 MVCC 是 InnoDB 存储引擎实现隔离级别的一种具体方式，用于实现提交读和可重复读这两种隔离级别。</p>
<p>加锁能解决多个事务同时执行时出现的并发一致性问题。在实际场景中读操作往往多于写操作。<br>读写锁能避免不必要的加锁操作，例如读和读没有互斥关系。但读写锁中读和写操作仍然是互斥的。<br>MVCC 利用了多版本的思想，写操作更新最新的版本快照，而读操作去读旧版本快照，没有互斥关系。</p>
<p>前面讲到脏读和不可重复读最根本的原因是事务读取到其它事务未提交的修改。在事务进行读取操作时，为了解决脏读和不可重复读问题，MVCC 规定只能读取已经提交的快照。</p>
<p>又分为：快照读和当前读。<br>快照读：MVCC 的 SELECT 操作是快照中的数据，不需要进行加锁操作。<br>当前读：MVCC 会对 INSERT、UPDATE、DELETE 进行加锁操作，从而读取最新的数据。可以看到 MVCC 并不是完全不用加锁，而只是避免了 SELECT 的加锁操作。</p>
<p>用 undo log 来实现 MVCC：undo log 用来记录版本快照。<br>MVCC 的多版本指的是多个版本的快照，快照存储在 undo log 中，该日志通过回滚指针 ROLL_PTR 把一个数据行的所有快照连接起来。<br>INSERT、UPDATE、DELETE 操作会创建一个日志，并将事务版本号 TRX_ID 写入。DELETE 可以看成是一个特殊的 UPDATE，此时还会额外将 DEL 字段设置为 1。</p>
<h3 id="Next-Key-Locks"><a href="#Next-Key-Locks" class="headerlink" title="Next-Key Locks"></a>Next-Key Locks</h3><p>可重复读下防止幻读，光 MVCC 是不够的，还需要间隙锁。</p>
<p>MySQL 中提供了两种封锁粒度：行级锁以及表级锁。</p>
<p>读写锁：</p>
<ul>
<li>写锁，又称排它锁，简写为 X 锁。</li>
<li>读锁，又称共享锁，简写为 S 锁。都是读时不会互斥。</li>
</ul>
<p>InnoDB 行锁是通过给索引上的索引项加锁来实现的。锁粒度小，锁冲突发生的概率最低，支持的并发度也最高。<br>但系统消耗成本也相对较高。加锁慢，会出现死锁。<br>行锁又分为：Record 、Gap 和 Next-Key。</p>
<ul>
<li>Record Locks：锁定一个记录上的索引，而不是记录本身。如果表没有设置索引，InnoDB 会自动在主键上创建隐藏的聚簇索引，因此 Record Locks 依然可以使用。</li>
<li>Gap Locks：锁定索引之间的间隙，但是不包含索引本身。</li>
<li>Next-Key Locks：是 Record Locks 和 Gap Locks 的结合，不仅锁定一个记录上的索引，也锁定索引之间的间隙。Next-Key Locks锁定一个左开右闭区间。<br>当查询的索引含有唯一属性时，将 Next-Key Locks 降级为 Record Locks。</li>
</ul>
<p>除了行级锁和表级锁，BDB 这个数据库还支持页锁，介于两者之间。</p>
<p>结合刚才讲到 MVCC 和 Next-Key Locks，在可重复读下防止幻读，因为间隙锁锁住了间隙，MVCC 进行正常的快照读。</p>
<h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>B+ Tree 索引：</p>
<img src="/images/blog8/图片3.png" />

<p>B+ Tree 是查找树，所有叶子节点位于同一层且包含了全部元素的信息，叶子节点用顺序访问指针连接。所有的中间节点元素都同时存在于子节点中，在子节点元素中是最大或最小的元素。</p>
<p>哈希索引：能以 O(1) 时间进行查找，但是失去了有序性。<br>自适应哈希索引：InnoDB 当某个索引值被使用的非常频繁时，会在 B+ Tree 索引之上再创建一个哈希索引，具备哈希快速查找的功能。</p>
<p>MyISAM 支持全文索引和空间数据索引，InnoDB 在 MySQL 5.6.4 版本中也开始支持全文索引。</p>
<h4 id="InnoDB-的-B-Tree-索引"><a href="#InnoDB-的-B-Tree-索引" class="headerlink" title="InnoDB 的 B+ Tree 索引"></a>InnoDB 的 B+ Tree 索引</h4><p>主索引的叶子节点 data 域记录着完整的数据记录，这种索引方式被称为聚簇索引。因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。</p>
<img src="/images/blog8/图片4.png" />

<p>辅助索引的叶子节点的 data 域记录着主键的值，因此在使用辅助索引进行查找时，需要先查找到主键值，然后再到主索引中进行查找。</p>
<img src="/images/blog8/图片5.png" />

<h2 id="MySQL-高级特性"><a href="#MySQL-高级特性" class="headerlink" title="MySQL 高级特性"></a>MySQL 高级特性</h2><h3 id="切分"><a href="#切分" class="headerlink" title="切分"></a>切分</h3><h4 id="水平切分"><a href="#水平切分" class="headerlink" title="水平切分"></a>水平切分</h4><p>水平切分又叫 Sharding，将同一个表中的记录按行拆分到多个结构相同的表中，每个库的表结构都一样，只不过每个库表放的数据是不同的。当一个表的数据不断增多时，Sharding 是必然的选择，它可以将数据分布到集群的不同节点上，从而缓解单个数据库的压力，达到分布式的目的。</p>
<h4 id="垂直切分"><a href="#垂直切分" class="headerlink" title="垂直切分"></a>垂直切分</h4><p>垂直切分将一张表按列切分成多个表，因为数据库是有缓存的，你访问频率高的行字段越少，就可以在缓存里缓存更多的行，性能就越好。</p>
<h4 id="数据库中间件"><a href="#数据库中间件" class="headerlink" title="数据库中间件"></a>数据库中间件</h4><p>数据库中间件用来分库分表。分为客户端和代理端。</p>
<ul>
<li>客户端：分片逻辑在应用端，封装在 JAR 包中，通过修改或者封装 JDBC 层来实现。如 Sharding-JDBC。</li>
<li>代理端：在应用和数据中间加了一个代理层。分片逻辑统一维护在中间件服务层中。如 MyCAT。</li>
</ul>
<h3 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h3><h4 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h4><ul>
<li>binlog 线程：在主库上把数据更改记录到二进制日志中。</li>
<li>I/O 线程：备库读取二进制日志并写入到自己的中继日志中。</li>
<li>SQL 线程：备库读取中继日志，解析出主库已经执行的数据更改并在从备库中重放。</li>
</ul>
<h4 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h4><p>主库负责写，从库负责读，避免了同一个库读写加锁，同时也体现了高可用性。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>由于分享内容过多，我使用上下两篇博客的形式，本篇讲述了 MySQL。下一篇将会记录 Redis 相关的内容。</p>
]]></content>
      <categories>
        <category>backend</category>
      </categories>
  </entry>
</search>
